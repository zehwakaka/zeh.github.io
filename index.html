<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Alice&#39;s blog">
<meta property="og:url" content="http://zehwakaka.github.io/index.html">
<meta property="og:site_name" content="Alice&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Alice&#39;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://zehwakaka.github.io/">





  <title>Alice's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Alice's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">郑</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2020/08/26/计算机网络复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/26/计算机网络复习/" itemprop="url">计算机网络复习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-26T17:09:08+08:00">
                2020-08-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h1><h2 id="1-3-互联网的组成"><a href="#1-3-互联网的组成" class="headerlink" title="1.3 互联网的组成"></a>1.3 互联网的组成</h2><ol>
<li><p>边缘部分：由所有连接在互联网上的主句组成。</p>
<p>端系统之间的通信方式通常可划分为两大类：</p>
<ul>
<li>客户-服务器方式(C/S方式)：即Client/Server方式，简称C/S方式。</li>
<li>对等方式(P2P方式)：即Peer-to-Peer方式。</li>
</ul>
</li>
<li><p>核心部分：由大佬网络和连载在这些完了的路由器组成。这部分是为边缘部分提供服务的(提供连通性和交换)</p>
<ul>
<li>网络中的核心部分要向网络边缘中的大量主机提供连通性。</li>
<li>在网络核心部分的主要设备是路由器。</li>
<li>路由器是实现1分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。</li>
</ul>
</li>
<li><p>分组交换的主要特点</p>
<ul>
<li>分组交换则采用<strong>存储转发</strong>技术</li>
<li>在发送端，先把较长的报文<strong>划分成较短的、固定长度的数据段。</strong></li>
<li>每一个数据段起那么添加上<strong>首部构成分组</strong></li>
<li>每个分组在互联中<strong>独立的选择传输路径</strong></li>
<li>用<strong>存储转发</strong>方式，最后分组到达<strong>最终目的地</strong></li>
<li>在接收端把收到的数据<strong>恢复为原来的报文</strong></li>
</ul>
</li>
</ol>
<h2 id="1-6-计算机网络的性能"><a href="#1-6-计算机网络的性能" class="headerlink" title="1.6 计算机网络的性能"></a>1.6 计算机网络的性能</h2><p>计算机网络的性能一般是指他的几个重要的性能指标，主要包括：</p>
<ol>
<li><p>速率</p>
<ul>
<li>速率是计算机网络中最重要的一个性能指标，指的是数据的传送速率，他也称为数据率或比特率。</li>
<li>速率的单位是bit/s，或kbit/s、Mbit/s、Gbit/s等。例如4*1010bit/s的数据率就记为40Gbit/s</li>
<li>速率往往是指额定速率或标称速率，非实际运行速率。</li>
</ul>
<ol start="2">
<li><p>带宽</p>
<ul>
<li>带宽本来是指信号具有的频带宽度，其单位是赫(或千赫、兆赫、吉赫等)。</li>
<li>在计算机网络中，带宽用来表示网络中某通道传送数据的能力。表示在单位时间内网络中的某信道所能通过的“最高数据率”。单位bit/s，即“比特每秒”。</li>
</ul>
</li>
</ol>
</li>
<li><p>吞吐量</p>
<ul>
<li>吞吐量表示在单位时间内通过某个网络(或信道、接口)的数据量。</li>
<li>吞吐量更经常的用于对现实世界的网络的一种测量，以便知道实际上到底有多少数据量能通过网络。</li>
<li>吞吐量受网络的带宽或网络的额定速率的限制。</li>
</ul>
</li>
<li><p>时延</p>
<ul>
<li><p>时延是指数据(一个报文或分组，甚至比特)从网络(或链路)的一端传送到另一端所需的时间。</p>
</li>
<li><p>有时也称为延迟或迟延</p>
</li>
<li><p>网络中的时延由以下几个不同的部分组成</p>
<ol>
<li><p>发送时延</p>
<ul>
<li>也称为传输时延。</li>
<li>发送数据时，数据帧从结点进入到传输媒体所需要的时间。</li>
<li>也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间</li>
<li>发送时延 = 数据帧长度(bit)/发送速率(bit/s)</li>
</ul>
</li>
<li><p>传播时延</p>
<ul>
<li>电磁波在信道中需要传播一定的距离而花费的时间</li>
<li>发送时延与传播时延有本质上的不同</li>
<li>信号发送速率和信号在信道上的传播速率是完全不同的概念</li>
<li>传播时延 = 信道长度(米)/信号在信道上的传播速率(米/秒)</li>
</ul>
</li>
<li><p>处理时延</p>
<p>主机或路由器在收到分组时，为处理分组(例如分析首部、提取数据、差错检验或查找路由)所花费的时间。</p>
</li>
<li><p>排队时延</p>
<ul>
<li>分组在路由器输入输出队列中排队等待处理所经历的时延。</li>
<li>排队时延的长短往往取决于网络中当时的通信量。</li>
</ul>
</li>
</ol>
</li>
<li><p>数据在网络中经历的总时延就是发送时延、传播时延、处理时延和排队时延之和。</p>
<p>总时延 = 发送时延+传播时延+处理时延+排队时延</p>
<p>必须指出，在总时延中，究竟是哪一种时延占主导地位，必须具体分析。</p>
</li>
<li><p>假设从结点A向结点B发送数据：在结点A中产生处理时延和排队时延，在发送器产生发送时延(即传输时延)，在链路上产生传播时延</p>
</li>
</ul>
</li>
<li><p>往返时间RTT</p>
<ul>
<li>互联网上的信息不仅仅单方向传输，而是双向交互的。因此，有时很需要知道双向交互一次所需的时间。</li>
<li>往返时间表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。</li>
<li>在互联网中，往返时间还包括各中间结点的处理时延、排队时延以及转发数据时的发送时延</li>
<li>当使用卫星通信时，往返时间RTT相对较长，是很重要的一个性能指标。</li>
</ul>
</li>
<li><p>利用率</p>
<ul>
<li><p>分为信道利用率和网络利用率。</p>
</li>
<li><p>信道利用率指出某信道有百分之几的时间是被利用的(有数据通过)。完全空闲的信道的利用率是零。</p>
</li>
<li><p>网络利用率则是全网络的信道利用率的加权平均值。</p>
</li>
<li><p>信道利用率并非越高越好。当某信道的利用率增大时，该信道引起的时延也就迅速增加。</p>
<p><em>时延与网络利用率的关系：当信道的利用率增大时，该信道引起的时延迅速增加。</em></p>
<p>​      </p>
</li>
</ul>
</li>
</ol>
<h2 id="1-7-计算机网络的体系结构"><a href="#1-7-计算机网络的体系结构" class="headerlink" title="1.7 计算机网络的体系结构"></a>1.7 计算机网络的体系结构</h2><ol>
<li><p>计算机网络体系结构的形成</p>
<ul>
<li>计算机网络是一个非常复杂的系统</li>
<li>互相通信的两个计算机系统必须高度协调工作才行，而这种”协调”是相当复杂的</li>
<li>“分层”可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。</li>
<li>计算机网络的各层及其协议的集合就是网络的体系结构</li>
</ul>
</li>
<li><p>协议与划分层次</p>
<ul>
<li><p>计算机网络中的数据交换必须遵守事先约定好的规则。</p>
</li>
<li><p>这些规则明确规定了所交换的数据的格式以及有关的同步问题(同步含有时序的意思)。</p>
</li>
<li><p>网络协议，简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。</p>
</li>
<li><p>网络协议的三个组成要素</p>
<ol>
<li><p>语法：数据与控制信息的结构或格式</p>
</li>
<li><p>语义：需要发出何种控制信息，完成何种动作以及做出何种响应。</p>
</li>
<li><p>同步：事件实现顺序的详细说明。</p>
<p><em>由此可见，网络协议是计算机网络的不可缺少的组成部分。</em></p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>具有五层协议的体系结构</p>
<ul>
<li>OSI的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。</li>
<li>TCP/IP是四层体系结构：应用层、运输层、网际层和网络接口层</li>
<li>但最下面的网络接口层并没有具体内容</li>
<li><strong>因此往往采取折中的办法，即OSI和TCP/IP的优点，采用一种只有五层协议的体系。</strong></li>
</ul>
<p><img src="/images/计算机网络体系结构.png" alt="计算机网络体系结构"></p>
<p><img src="/images/主机1向主机2发送数据.png" alt="主机1向主机2发送数据"></p>
</li>
</ol>
<hr>
<h1 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h1><h2 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h2><ul>
<li>常用术语<ul>
<li>数据——运送消息的实体</li>
<li>信号——数据的电气的或电磁的表现</li>
<li>模拟信号——代表消息的参数的取值是连续的</li>
<li>数字信号——代表消息的参数的取值是离散的</li>
<li>码元——在使用时间域(或简称为时域)的波形表示数字信号时，代表不同离散数值的基本波形</li>
</ul>
</li>
</ul>
<h2 id="2-2-数据通信的基础知识"><a href="#2-2-数据通信的基础知识" class="headerlink" title="2.2 数据通信的基础知识"></a>2.2 数据通信的基础知识</h2><ol>
<li><p>有关信道的几个基本概念</p>
<ul>
<li>信道——一般来表示向某一个方向传送信息的媒体</li>
<li>单向通信(单工通信)——只能有一个方向的通信而没有反方向的交互</li>
<li>双向交替通信(半双工通信)——通信的双方都可以发送信息，当不能双方同时发送(当然也就不能同时接收)。</li>
<li>双向同时通信(全双工通信)——通信的双方可以同时发送和接收信息。</li>
</ul>
</li>
<li><p>有关信道的几个基本概念</p>
<ul>
<li><p>基带信号(即基本频带信号)——来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</p>
</li>
<li><p>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行<strong>调制</strong>。</p>
</li>
<li><p>调制分为两大类：</p>
<ul>
<li>基带调制：仅对基带信号的波形进行变换，使它能够与信道特征性相适应。变换后的信号仍然是基带信号。把这种过程称为编码。</li>
<li>带通调制：使用<strong>载波</strong>进行调制，把基带信号的频率范围搬移到较高的频段，并<strong>转换为模拟信号</strong>，这样就能够更好的在模拟信道中传输(即仅在一段频率范围内能够通过信道)。</li>
<li>带通信号：经过载波调制后的信号。</li>
</ul>
</li>
<li><p>基本的带通调制方法</p>
<ul>
<li><p>最基本的二元制调制方法有以下几种：</p>
<ol>
<li>调幅(AM)：载波的振幅随基带数字信号而变化。</li>
<li>调频(FM)：载波的频率随基带数字信号而变化。</li>
<li>调相(PM)：载波的初始相位随基带数字信号而变化。</li>
</ol>
<p><img src="\images\最基本的三种调制方式.png" alt="最基本的三种调制方式"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>信道的极限容量</p>
<ul>
<li><p>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。</p>
</li>
<li><p>码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。</p>
</li>
<li><p>从概念上讲，限制码元在信道上的传输速率的因素有以下两个：</p>
<ul>
<li>信道能够通过的频率范围</li>
<li>信噪比</li>
</ul>
</li>
<li><p>信噪比</p>
<ul>
<li>噪声存在于所有的电子设备和通信信道中</li>
<li>噪声是随机产生的，它的瞬时值有时会很大。因此噪声会使接收端对码元的判决产生错误。</li>
<li>但噪声的影响是相对的。如果信号相对较强，那么噪声的影响就相对较小。</li>
<li>信噪比就是信号的平均功率和噪声的平均功率之比。常记为S/N，并用分贝(dB)作为度量单位。即：信噪比(dB) = 10log10(S/N) （dB）</li>
<li>例如，当S/N = 10时，信噪比为10dB,而当S/N =1000时，信噪比为30dB。</li>
</ul>
</li>
<li><p>香农公式</p>
<ul>
<li><p>奈奎斯特于1924年推导出在理想低通信道下的<strong>最高码元传输速率(波特率)</strong>的公式，公式表示为理想低通信道下的最高码元传输速率=2W Baud</p>
</li>
<li><p>1984年，香农用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率(香农公式)</p>
</li>
<li><p>信道的极限信息传输速率C可表达为：</p>
<p>C = Wlog2(1+S/N)  (bit/s)</p>
<p>其中：W为信道的带宽(以Hz为单位)；</p>
<p>S为信道内所传信号的平均功率；</p>
<p>N为信道内部的高斯噪声功率。</p>
</li>
</ul>
</li>
<li><p>香农公式表明</p>
<ul>
<li>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。</li>
<li>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。</li>
<li>若信道带宽W或信噪比S/N没有上限(当然实际信道不可能是这样的)，则信道的极限信息传输速率C也就没有上限。</li>
<li>实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="2-3-物理层下面的传输媒体"><a href="#2-3-物理层下面的传输媒体" class="headerlink" title="2.3 物理层下面的传输媒体"></a>2.3 物理层下面的传输媒体</h2><ol>
<li><p>引导型传输媒体</p>
<ul>
<li>双绞线</li>
<li>同轴电缆</li>
<li>光缆</li>
</ul>
</li>
<li><p>非引导型传输媒体</p>
<ul>
<li>自由空间</li>
</ul>
</li>
</ol>
<h2 id="2-4-信道复用技术"><a href="#2-4-信道复用技术" class="headerlink" title="2.4 信道复用技术"></a>2.4 信道复用技术</h2><ol>
<li><p>频分复用、时分复用和统计时分复用</p>
<ul>
<li><p>频分复用(FDM)</p>
<ul>
<li>将整个宽带分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li>
<li>频分复用的所有用户在同样的时间占用不同的带宽资源(请注意，这里的“带宽”是频率带宽而不是数据的发送速率)。</li>
</ul>
</li>
<li><p>时分复用(TDM)</p>
<ul>
<li>时分复用则是将时间划分为一段段等长的时分复用帧(TDM帧)。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙。</li>
<li>每一个用户所占用的时隙是周期性的出现(其周期就是TDM帧的长度)。、</li>
<li>TDM信号也称为等时信号。</li>
<li>时分复用的所有用户是在不同的时间占用同样的频带宽度。</li>
</ul>
</li>
<li><p>波分复用(WDM)</p>
<ul>
<li>波分复用就是光的频分复用。使用一根光纤来同时传输多个光载波信号.</li>
</ul>
</li>
<li><p>码分复用(CDM)</p>
<ul>
<li><p>常用的名词是码分多址CDMA</p>
</li>
<li><p>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。</p>
</li>
<li><p>这种系统发送的信号有很强的抗干扰能力，其频谱类似白噪声，不易被敌人发现。</p>
<ol>
<li><p>码片序列</p>
<ul>
<li><p>每一个比特时间划分为m个短的间隔，称为码片。</p>
</li>
<li><p>每一个站被指派一个唯一的m bit码片序列。</p>
<p>如发送比特1，则发送自己的 m bit 码片序列。</p>
<p>如发送比特0，则发送该码片序列的二进制反码。</p>
</li>
<li><p>例如，S站的8bit码片序列是00011011</p>
<p>发送比特1时，就发送序列00011011</p>
<p>发送比特0时，就发送序列11100100</p>
</li>
<li><p>S站的码片序列：(-1 -1 -1 +1 +1 -1 +1 +1)</p>
</li>
</ul>
</li>
<li><p>CDMA的重要特点</p>
<ul>
<li>每个站分配的码片序列不仅必须各不相同，并且还必须相互正交。</li>
<li>在实用的系统中是使用伪随机码序列</li>
</ul>
</li>
<li><p>码片序列的正交关系</p>
<ul>
<li><p>令向量S表示站S的码片向量，令T表示其他任何站的码片向量。</p>
</li>
<li><p>两个不同站的码片序列正交，就是向量S和T的规格化内积等于0：</p>
<p><img src="/images/规格化内积.png" alt="规格化内积"></p>
</li>
</ul>
</li>
<li><p>正交关系的另一个重要特性</p>
<ul>
<li>任何一个码片向量和该码片向量自己的规格化内积都是1。</li>
<li><img src="/images/公式.png" alt="公式"></li>
<li>一个码片向量和该码片反码的向量的规格化内积值是-1.</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>​      </p>
<h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h1><h2 id="3-1-使用点对点信道的数据链路层"><a href="#3-1-使用点对点信道的数据链路层" class="headerlink" title="3.1 使用点对点信道的数据链路层"></a>3.1 使用点对点信道的数据链路层</h2><ul>
<li>数据链路层协议有许多种，但有三个基本问题则是共同的。三个基本问题是：<ol>
<li>封装成帧<ul>
<li>封装成帧就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。</li>
<li>首部和尾部的一个重要作用就是进行帧定界。</li>
<li><img src="/images/用帧首部和帧尾部封装成帧.png" alt="用帧首部和帧尾部封装成帧"></li>
<li>当数据是由可打印的ASCLL码组成的文本文件时，帧定界可以使用特殊的帧定界符。</li>
<li>控制字符SOH放在一帧的最前面，表示帧的首部开始。另一给控制字符EOT表示帧的结束。</li>
</ul>
</li>
<li>透明传输<ul>
<li>如果数据中的某个字节的二进制代码恰好和SOH或EOT一样，数据链路层就会错误的”找到帧的边界”。</li>
<li>解决方法：字节填充或字符填充</li>
<li>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是1B)</li>
<li>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li>
<li>如果转义字符也出现在数据当中，那么应在转义字符前面插入一组转义字符ESC。当接收端收到联系的两个转义字符时，就删除其中前面的一个。</li>
</ul>
</li>
<li>差错控制<ul>
<li>在传输过程中可能会产生比特差错：1可能会变成0而0也可能变成1。</li>
<li>在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER。</li>
<li>误码率与信噪比有很大的关系。</li>
<li>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种查错检测措施。</li>
<li></li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="3-3-使用广播信道的数据链路层"><a href="#3-3-使用广播信道的数据链路层" class="headerlink" title="3.3 使用广播信道的数据链路层"></a>3.3 使用广播信道的数据链路层</h2><h2 id="3-4-扩展的以太网"><a href="#3-4-扩展的以太网" class="headerlink" title="3.4 扩展的以太网"></a>3.4 扩展的以太网</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2020/08/22/hexo常用命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/22/hexo常用命令/" itemprop="url">hexo常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-22T15:14:41+08:00">
                2020-08-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><pre><code>hexo new &quot;postName&quot; #新建文章
hexo generate #生成静态页面至public目录
hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）
hexo deploy #部署到GitHub
hexo help  # 查看帮助
hexo version  #查看Hexo的版本
</code></pre><h2 id="缩写："><a href="#缩写：" class="headerlink" title="缩写："></a>缩写：</h2><pre><code>hexo n == hexo new
hexo g == hexo generate
hexo s == hexo server
hexo d == hexo deploy
</code></pre><h2 id="组合命令："><a href="#组合命令：" class="headerlink" title="组合命令："></a>组合命令：</h2><pre><code>hexo s -g #生成并本地预览
hexo d -g #生成并上传
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2020/08/22/数据库概论复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/22/数据库概论复习/" itemprop="url">数据库概论复习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-22T15:10:42+08:00">
                2020-08-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>版权所有</em></p>
<hr>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h3><ul>
<li>数据库四个基本概念：数据库系统(DBS)包括 数据库管理系统(DBMA)，数据库管理员(DBA)，数据库(DB)。</li>
<li>数据管理技术的产生和发展：数据管理技术经历了人工管理、文件管理、数据库系统三个阶段。     </li>
<li>数据库系统的特点</li>
</ul>
<ol>
<li>数据结构化<ol start="2">
<li>共享性高、冗余度低且易扩充</li>
<li>数据独立性高：数据独立性、物理独立性、逻辑独立性</li>
<li>数据由数据库管理系统统一管理和控制</li>
</ol>
</li>
</ol>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><ul>
<li><p>据模型也是一种模型，它是对现实世界数据特征的抽象。数据模型是数据库系统的核心和基础。</p>
</li>
<li><p>两类数据模型：第一类是概念模型，第二类是逻辑模型和物理模型。 首先将现实世界抽象为信息世界，然后将信息世界转换为机器世界。</p>
</li>
<li><p>概念模型：概念模型最常用的方法是实体-联系方法，E-R方法也称为E-R模型</p>
<ol>
<li>实体：客观存在并可互相区别的事物称为实体。</li>
<li>属性：实体所具有的某一特性称为属性。</li>
<li>码：唯一标识实体的属性集称为码。</li>
<li>实体型：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。</li>
<li>实体集：同一类型实体的集合称为实体集</li>
<li>联系：实体之间的联系通常是指不同实体集之间的联系。实体之间的联系有一对一、一对多和多对多等多种类型。<br>数据模型的组成要素</li>
</ol>
</li>
<li><p>数据结构：数据结构描述数据库的组成对象以及对象之间的联系。</p>
</li>
<li><p>数据操作：数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。</p>
</li>
<li><p>数据的完整性约束条件：数据的完整性约束条件是一组完整性规则。</p>
</li>
<li><p>常用的数据模型</p>
<ol>
<li><p>层次模型</p>
</li>
<li><p>网状模型</p>
</li>
<li><p><strong>关系模型</strong></p>
<ol>
<li><p>关系模型的数据结构</p>
<ul>
<li><p>关系：一个关系对应通常说的一张表</p>
</li>
<li><p>元组：表中的一行即为一个元组</p>
</li>
<li><p>属性：表中的一列即为一个属性，给每一个属性起一个名称即属性名</p>
</li>
<li><p>码：也称码键。表中的某个属性组，它可以唯一确定一个元组</p>
</li>
<li><p>域：域是一组具有相同数据类型的值的集合</p>
</li>
<li><p>分量：元组中的一个属性值</p>
<p><em>关系模型要求关系必须是规范的，关系的每一个分量必须是一个不可分的数据项</em></p>
</li>
</ul>
</li>
<li><p>关系模型的数据操纵与完整性约束</p>
<p><em>关系模型中的数据操作是集合操作，操作对象和操作结果都是关系。关系模型把存取路径向用户隐蔽起来</em></p>
</li>
<li><p>关系模型的优缺点</p>
<ul>
<li>关系模型与格式化模型不同，他是建立在严格的数学基础上的。</li>
<li>关系模型的概念单一</li>
<li>关系模型的存取路径对用户透明</li>
</ul>
</li>
</ol>
</li>
<li><p>面向对象数据模型</p>
</li>
<li><p>对象关系数据模型</p>
</li>
<li><p>半结构化数据模型</p>
</li>
</ol>
</li>
</ul>
<h3 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h3><ul>
<li><p>数据库系统模式的概念：在数据模型中有“型”和“值”的概念。型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值。</p>
<p><em>模式是相对稳定的，而实例是相对变动的。</em></p>
</li>
<li><p><strong>数据库系统的三级模式结构图：</strong></p>
</li>
<li><p><img src="/images/数据库系统的三级模式结构.jpg" alt="数据库系统的三级模式结构" style="zoom:25%;transform:rotate(-90deg);">    </p>
</li>
<li><p><strong>三级模式</strong></p>
<ol>
<li><p>模式：模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p>
</li>
<li><p>外模式：外模式也称子模式或用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</p>
</li>
<li><p>内模式：内模式也称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。</p>
</li>
</ol>
</li>
<li><p><strong>数据库的二级映像功能与数据独立性</strong></p>
<ol>
<li><p>外模式/模式映像：当模式改变时(例如增加新的关系、新的属性、改变属性的数据类型等)，由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，<strong>保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。</strong></p>
</li>
<li><p>模式/内模式映像：当数据库的存储结构改变时(例如选用了另一种存储结构)，由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变。<strong>保证了数据与程序的物理独立性，简称数据的物理独立性。</strong></p>
<p><em>数据与程序之间的独立性使得数据的定义和描述可以从应用程序中分离出去。另外，由于数据的存取由数据库管理系统管理，从而简化了应用程序的编制，大大减少了应用程序的维护和修改。</em></p>
</li>
</ol>
</li>
<li><p>据库系统的组成</p>
<ul>
<li><p>包括硬件平台及数据库、软件、人员。</p>
</li>
<li><p>数据库管理员(DBA)职责：</p>
<ul>
<li>决定数据库中的信息内容和结构</li>
<li>决定数据库的存储结构和存储策略</li>
<li>定义数据的安全性要求和完整性约束条件</li>
<li>监控数据库的使用和运行</li>
<li>数据库的改进和重组、重构</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章 关系数据库"></a>第二章 关系数据库</h2><h3 id="关系数据结构及形式化定义"><a href="#关系数据结构及形式化定义" class="headerlink" title="关系数据结构及形式化定义"></a>关系数据结构及形式化定义</h3><ul>
<li><p>关系</p>
<ol>
<li><p>域：域是一组具有相同数据类型的值的集合。</p>
</li>
<li><p><strong>笛卡尔积</strong>：笛卡尔积定义，给定一组域D1,D2,…,Dn，允许其中某些域是相同的，D1,D2,…,Dn的笛卡尔积为</p>
<p>​                                                        <em>D1\</em>D2*…*Dn = {(d1,d2,…,dn)|di属于Di,i=1,2,…,n}*<br>​                           其中，每一个元素(d1,d2,…,dn)叫作一个n元组，或简称元组。元素中的每一个值di叫作一个分量。<br>​                           一个域允许的不同取值个数称为这个域的基数。</p>
</li>
<li><p><strong>关系：</strong>定义，D1*D2*…*Dn的子集叫做在域D1,D2,…,Dn上的关系，表示为R(D1,D2,…,Dn)这里R表示关系的名字,n是关系的<strong>目或度</strong>。当n = 1时，称该关系为一元关系。当n = 2时，称该关系为二元关系。</p>
<ul>
<li><p>某一属性组的值能唯一的标识一个元组，而其子集不能，则称该属性组为<strong>候选码</strong>。若一个关系有多个候选码，则选定其中一个为<strong>主码</strong>。候选码的诸属性称为<strong>主属性</strong>。不包含在任何候选码中的属性称为<strong>非主属性或非码属性</strong>。在最简单的情况下，候选码只包含一个属性。在最极端的情况下，关系模式的所有属性是这个关系模式的候选码，称为<strong>全码</strong>。</p>
</li>
<li><p>关系可以有三种类型：基本关系(通常又称为基本表或基表)、查询表和视图表。</p>
</li>
<li><p>关系的性质：</p>
<ol>
<li><p>列是同质的，即每一列中的分量是同一类型的数据，来自同一个域。</p>
</li>
<li><p>不同的列可出自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。</p>
</li>
<li><p>列的顺序无所谓，即列的次序可以任意交换。</p>
</li>
<li><p>任意两个元组的候选码不能取相同的值。</p>
</li>
<li><p>行的顺序无所谓，即行的次序可以任意交换。</p>
</li>
<li><p>分量必须取原子值，即每一个分量都必须是不可分的数据项</p>
<p><strong>这些规范条件中最基本的一条就是，关系的每一个分量必须是一个不可分的数据项。规范化的关系简称为范式(NF)。</strong></p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>关系模式</p>
<ul>
<li>关系的描述称为关系模式。它可以形式化的表示为R(U,D,DOM,F)。其中R为关系名，U为组成改关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合。</li>
</ul>
</li>
<li><p>关系数据库</p>
<ul>
<li>关系数据库也有型和值之分。关系数据库的型也称为关系数据库模式，是对关系数据库的描述。关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。</li>
</ul>
</li>
</ul>
<h3 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h3><ul>
<li><p>基本的关系操作：关系模型中常用的关系操作包括<strong>查询操作</strong>和<strong>插入、删除、修改操作</strong>两大部分。</p>
<ul>
<li><p>关系的查询表达能力很强，是关系操作中最主要的部分。查询操作又可以分为旋转、投影、连接、除、并、差、交、笛卡尔积等。其中<strong>选择、投影、并、差、笛卡尔积是5种基本操作</strong>。</p>
</li>
<li><p>关系操作的特点是集合操作方式，即操作的对象和结果都是集合。这种操作方式也称为一次一集合的方式。相应的非关系数据模型的数据操作方式则为一次一记录的方式。</p>
</li>
</ul>
</li>
<li><p>关系数据语言的分类</p>
<ul>
<li><p>早期的关系操作能力通常用代数方式或逻辑方式来表示，分别称为<strong>关系代数和关系演算</strong>。关系代数用对关系的运算来表达查询要求，关系演算则用谓词来表达查询要求。关系演算又可按谓词变元的基本对象是元组变量还是域变量分为<strong>元组关系演算和域关系演算</strong>。</p>
</li>
<li><p>还有一种介于关系代数和关系演算之间的<strong>结构化查询语言(SQL)</strong>。SQL是<strong>集查询、数据定义语言、数据操纵语言和数据控制语言于一体的关系数据语言。</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h3><ul>
<li><p>关系模型中有三类完整性约束：<strong>实体完整性、参照完整性和用户定义的完整性。</strong>其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作<strong>关系的两个不变性。</strong></p>
<ol>
<li><p>实体完整性：实体完整性规则，若属性(指一个或一组属性)A是基本关系R的主属性，则A不能取空值。所谓空值就是“不知道”或“不存在”或“无意义”的值。</p>
<p><em>对实体完整性规则说明：</em></p>
<ul>
<li><p>实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。</p>
</li>
<li><p>现实世界中的实体是可区分的，即它们具有某种唯一性标识。例如每个学生都是独立的个体，是不一样的。</p>
</li>
<li><p>相应的，关系模型中以主码作为唯一性标识。</p>
</li>
<li><p>主码中的属性不能取空值。</p>
</li>
</ul>
</li>
<li><p>参照完整性：<strong>设F是基本关系R的一个或一组属性，但不是关系R的码，Ks是基本关系S的码。如果F与Ks相对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。</strong></p>
<p><img src="/images/参照关系.jpg" alt="参照关系与被参照关系"></p>
<ul>
<li><p>参照完整性规则：若属性(或属性组)F是基本关系R的外码，它与基本关系S的主码Ks相对应(基本关系R和S不一定是不同的关系)，则对于R中每个元组在F上的值必须：</p>
<ol>
<li><p>或者取空值(F的每个属性值均为空值)</p>
</li>
<li><p>或者等于S中某个元组的主码值。</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>用户定义的完整性</p>
<p><em>用户定义的完整性就是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。</em></p>
</li>
</ol>
</li>
</ul>
<h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p>  关系代数是一种抽象的查询语言，它用对关系的运算来表达查询。</p>
<p>  任何一种运算都是将一定的运算符作用于一定的运算对象上，得到预期的运算结果。所以运算对象、运算符、运算结果是运算的三大要素。</p>
<p>  关系代数用到的运算符包括两类：集合运算符和专门的关系运算符</p>
<p>  关系代数的运算按运算符的不同可分为传统的集合运算和专门的关系运算两类。</p>
<ul>
<li><p>传统的集合运算</p>
<p><strong>传统的集合运算是二目运算，包括并、差、交、笛卡尔积四种运算</strong></p>
<p>定义如下：</p>
<ol>
<li><p>并：R∪S ={t|t属于R V t属于S}    其结果仍为n目关系，由属于R或属于S的元组组成。</p>
</li>
<li><p>差：R-S = {t|t属于R ∧ t不属于S}  其即结果关系仍为n目关系，由属于R而不属于S的所有元组组成。</p>
</li>
<li><p>交：R∩S = {t|t属于R ∧ t属于S}    其结果关系仍为n目关系，由既属于R又属于S的元组组成。关系的交可以用差来表示，即</p>
<p>R∩S = R - (R - S)</p>
</li>
<li><p>笛卡尔积：R*S = {tr 连ts|tr属于R ∧ ts属于S}</p>
<p><img src="\images\传统集合运算举例.jpg" alt="传统集合运算举例"></p>
</li>
</ol>
</li>
<li><p>专门的关系运算</p>
<p><strong>专门的关系运算包括选择、投影、连接、除运算</strong></p>
<p> 记号：</p>
<ol>
<li><p>设关系模式为R(A1,A2,…,An)，它的一个关系设为R。t属于R表示t是R的一个元组。t[Ai]则表示元组t中相应于属性Ai的一个分量。</p>
</li>
<li><p>若A = {Ai1,Ai2,…,Aik}，其中Ai1，Ai2，…，Aik是A1，A2，…，An中的一部分，则A称为属性列或属性组。t[A] = (t[Ai1],t[Ai2],…,t[Aik])表示元组t在属性列A上诸分量的集合，A反则表示{A1,A2,…,An}中去掉{Ai1,Ai2,…,Aik}后剩余的属性组。</p>
</li>
<li><p>R为n目关系，S为m目关系。tr属于R，ts属于S，tr连接ts称为元组的连接或元组的串接。他是一个n+m列的元组前n个分量为R中的一个n元组，后m个分量为S中的一个m元组。</p>
</li>
<li><p>给定一个关系R(X,Z),X和Z为属性组。当t[X] = x时，x在R<strong>象集</strong>定义为</p>
<p>​    Zx = {t[Z]|t属于R，t[X] = x}</p>
<p>它表示R中属性组X上值为x的诸元组在Z上分量的集合。</p>
</li>
</ol>
<ul>
<li><p>选择：选择又称为限制。它是在关系R中选择满足给定条件的诸元组，记作   的塔F(R) = {t|t属于R ∧ F(t)= ‘真’}</p>
</li>
<li><p>投影：关系R上的投影是从R中选择出若干属性列组成新的关系。记作   pi A(R) = {t[A]|t属于R} 其中A为R中的属性列。投影是从列的角度进行的运算。</p>
</li>
<li><p>连接：连接也称为 θ连接。他是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。记作：</p>
<p> <img src="/images/连接.jpg" alt="连接"> </p>
<ul>
<li><p>连接运算中有两种最为重要也最为常用的连接，一种是等值连接，另一种是自然连接。θ为“=”的连接运算称为<strong>等值连接</strong>是从关系R与S的广义笛卡尔积中选取A、B属性值相等的那些元组。<strong>自然连接</strong>是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉。即若R和S中具有相同的属性组B,U为R和S的全体属性集合。一般的连接操作是从行的角度进行运算，但自然连接还需要取消重复列，所以是<strong>同时从行和列的角度进行运算</strong>。</p>
</li>
<li><p>两个关系R和S在做自然连接时，选择两个关系在公共属性上值相等的元组构成新的关系。此时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃，同样，S中某些元组也可能被舍弃。<strong>这些被舍弃的元组称为悬浮元组</strong>。</p>
</li>
<li><p>如果把悬浮元组也保存在结果关系中，而在其他属性上填空值(NULL)，那么这种连接就叫做外连接，记作R =&gt;&lt;= S;如果只保留左边关系R中的悬浮元组就叫做左外连接R=&gt;&lt;S;如果只保留右边关系S中的悬浮元组就叫做右外连接，记作R&gt;&lt;=S</p>
</li>
</ul>
</li>
<li><p>除运算：设关系R除以关系S的结果为关系T，则<strong>T包含所有在R但不在S中的属性及其值，且T的元组与S的元组的所有组合都在R中。</strong></p>
<ul>
<li>下面用象集来定义除法：给定关系R(X,Y)和S(Y,Z)，其中X,Y,Z为属性组。R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集。</li>
<li>R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在X属性列上的投影：元组在X上分量值x的象集Yx包含S在Y上投影的集合。记作：R/S = {Tr[X]|tr属于R ∧ piY(S)包含于Yx} 其中Yx为x在R中的象集，x = tr[X]。除操作是同时从行和列角度进行运算。</li>
<li>R/S -&gt;投影-&gt;象集-&gt;包含</li>
</ul>
</li>
</ul>
</li>
<li><p>其中并，差，笛卡尔积，选择和投影这五种运算为基本的运算。其他三种运算，即交，连接和除，均可以用这5种基本运算来表达。引进他们并不增加语言的能力，但可以简化表达</p>
</li>
<li><p>关系代数中，这些运算经有限次复合后形成的表达式称为关系代数表达式。</p>
</li>
</ul>
<hr>
<h2 id="第三章-关系数据库标准语言SQL"><a href="#第三章-关系数据库标准语言SQL" class="headerlink" title="第三章 关系数据库标准语言SQL"></a>第三章 关系数据库标准语言SQL</h2><h3 id="SQL-概述"><a href="#SQL-概述" class="headerlink" title="SQL 概述"></a>SQL 概述</h3><ul>
<li><p>SQL 的产生与发展</p>
<p>目前，没有一个数据库系统能够支持SQL标准的所有概念和特性。大部分数据库系统能支持SQL/92标准中的大部分功能以及SQL99、SQL2003中的部分新概念。同时，许多软件厂商对SQL基本命令集还进行了不同程度的扩展和修改，又可以支持标准以外的一些功能特性。</p>
</li>
<li><p>SQL的特点</p>
<ol>
<li><p>综合统一</p>
</li>
<li><p>高度非过程化</p>
<p>只要提出“做什么”，而无须指明“怎么做”，因此无须了解存取路径。存取路径的选择以及SQL的操作过程由系统自动完成。</p>
</li>
<li><p>面向集合的操作方式</p>
</li>
<li>以同一种语法结构提供多种使用方式</li>
<li>语言简洁，易学易用 </li>
</ol>
</li>
</ul>
<h3 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h3><p><em>一个关系数据库管理系统的实例中可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象。</em></p>
<p><img src="/images/数据库对象命名机制的层次结构.jpg" alt="数据库对象命名机制的层次结构"></p>
<ul>
<li><p>模式的定义与删除</p>
<ul>
<li><p>定义模式：在SQL中，模式定义语句如下：create schema &lt;模式名&gt; authorization &lt;用户名&gt; </p>
<p>​                                                     <em>如果没有指定&lt;模式名&gt;，那么&lt;模式名&gt;隐含为&lt;用户名&gt;</em></p>
<p><em>要创建模式，调用该命令的用户必须拥有数据库管理员权限，或者获得了数据库管理员授予的create schema 的权限</em></p>
</li>
<li><p>目前，create chema 中可以接受 create table，create view和grant 子句。也就是说用户可以在创建模式的同时在这个模式定义中进一步创建基本表、视图。定义授权。即：create schema &lt;模式名&gt; authorization &lt;用户名&gt; [&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]</p>
</li>
<li><p>删除模式：在SQL中，删除模式语句如下，drop schema &lt;模式名&gt;&lt;cascade|restrict&gt; </p>
<p><em>其中cascade和restrict两者必选其一。选择了cascade(级联)，表示在删除模式的同时把该模式中所有的数据库对象全部删除；选择了restrict(限制)，表示如果该模式中已经定义了下属的数据库对象(如表，视图等)，则拒绝该删除语句的执行。只有当该模式中没有任何下属的对象时才能执行 drop schema语句。</em></p>
</li>
</ul>
</li>
<li><p>基本表的定义、删除与修改</p>
<ul>
<li><p>定义基本表：创建了一个模式就建立了一个数据库的命名空间，一个框架。在这个空间中首先要定义的是该模式包含的数据库基本表。SQL语言使用create table 语句定义基本表，其基本格式如下：</p>
<p><em>create table &lt;表名&gt;(&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件][,&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件]][,表级完整性约束条件])</em></p>
<p><em>参照表和被参照表可以是同一个表</em></p>
</li>
<li><p>数据类型：</p>
<p><img src="\images\数据类型1.jpg" alt="数据类型1"><br><img src="\images\数据类型2.jpg" alt="数据类型1"></p>
</li>
<li><p>模式与表</p>
<p>每一给基本表都属于某一个模式，一个模式包含多个基本表。当定义基本表时一般可以有三种方法定义它所属的模式，现在要在S-T中定义Student、Course、SC等基本表。</p>
<ol>
<li><p>方法一：在表名中明显的给出模式名。 create table ”S-T“.Student(…);<em>Student所属的模式是S-T</em></p>
</li>
<li><p>方法二：在创建模式语句中同时创建表</p>
</li>
<li><p>方法三：设置所属的模式，这样在创建表时表名中不必给出模式名。</p>
<p>当用户创建基本表(其他数据库对象也一样)时若没有指定模式，系统根据搜索路径来确定该对象所属的模式。</p>
<p>搜索路径包含一组模式列表，关系数据库管理系统会使用模式列表中第一个存在的模式作为数据库对象的模式名。若搜索路径中的模式名都不存在，系统将给出错误。</p>
<p><em>使用下面的语句可以显示当前的搜索路径： show search_path</em></p>
<p><em>搜索路径当前默认值是$user，PUBLIC。其含义是首先搜索与用户名相同的模式名，如果该模式名不存在，则使用PUBLIC模式</em></p>
<p><em>数据库管理员也可以设置搜索路径，如：SET search_path TO “S-T”,PUBLIC; 然后，定义基本表。实际结果是建立了S-T.Student基本表。因为关系数据库管理系统发现路径中第一个模式名S-T存在，就把该模式作为基本表Studnt所属的模式。</em></p>
</li>
</ol>
</li>
<li><p>修改基本表</p>
<p>SQL语言用alter table语句修改基本表，其一般格式为</p>
<p>alter table &lt;表名&gt;</p>
<p>[add [column] &lt;新列名&gt;&lt;数据类型&gt;[完整性约束]]</p>
<p>[add &lt;表级完整性约束&gt;]</p>
<p>[drop [column] &lt;列名&gt;[cascade|restrict]]</p>
<p>[drop constraint &lt;完整性约束名&gt; [restrict|cascade]]</p>
<p>[alter column &lt;列名&gt;&lt;数据类型&gt;]</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>删除基本表</p>
<p>drop table &lt;表名&gt;[restrict|cascade]</p>
<p>若选择restrict，则该表的删除是有限制条件的。欲删除的基本表不能被其他表的约束所引用(如cheack，foreign key等约束)，不能有视图，不能有触发器，不能有存储过程或函数等。如果存在这些依赖该表的对象，则此表不能被删除。</p>
<p>若选择cascade，则该表的删除没有限制条件。在删除基本表的同时，相关的依赖对象，例如视图，都将被一起删除。</p>
<p><em>默认情况是restrict</em></p>
</li>
<li><p>索引的建立与删除</p>
<p>数据库索引有多种类型，常见索引包括顺序文件上的索引、B+树索引、散列索引、位图索引等。<strong>顺序文件上的索引</strong>是针对按指定属性值升序或降序存储的关系，在该属性上建立一个顺序索引文件，索引文件由属性值和相应的元组指针组成。<strong>B+树索引</strong>是将索引属性组织成B+树形式，B+树的叶结点为属性值和相应的元组指针。B+树索引具有动态平衡的优点。<strong>散列索引</strong>是建立若干个桶，将索引属性按照其散列函数值映射到相应桶中，桶中存放索引属性值和相应的元组指针。散列索引具有查找速度快的特点。<strong>位图索引</strong>是用位向量记录所有属性中可能出现的值，每个位向量对于一个可能值。</p>
<p><em>关系数据库管理系统在执行查询时会自动选择合适的索引作为存取路径，用户不必也不能显式的选择索引。</em></p>
<ol>
<li><p>建立索引：在SQL语言中，建立索引使用 create index 语句，一般格式为</p>
<p>create [unique][cluster] index &lt;索引名&gt;</p>
<p>on &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;]]…)</p>
<p>其中，&lt;表名&gt;是要建索引的基本表的名字。索引可以建立在该表的一列或多列上，各列名之间用逗号分隔。每个&lt;列名&gt;后面还可以用&lt;次序&gt;指定索引值的排列次序，可选ASC(升序)或DESC(降序)，默认值为ASC.</p>
<p>UNIQUE表明此索引每一个索引值只对应唯一的数据记录。</p>
<p>CLUSTER 表示要建立的索引是聚簇索引。</p>
</li>
<li><p>修改索引</p>
<p>对于已经建立的索引，如果需要对其重新命名，可以使用ALTER INDEX 语句。其一般格式为：</p>
<p>ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;</p>
</li>
<li><p>删除索引</p>
<p>在SQL中，删除索引使用DROP INDEX语句，其一般格式为</p>
<p>DROP INDEX &lt;索引名&gt;</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>数据字典</p>
<p>数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有的定义信息，包括关系模式定义，视图定义，索引定义，完整性约束定义，各类用户对数据库的操作权限，统计信息等。</p>
</li>
</ul>
<h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><ul>
<li><p>数据查询是数据库的核心操作。SQL提供了SELECT语句进行数据查询，该语句具有灵活的使用方式和丰富的功能。其一般格式为</p>
<p>select [all|distinct] &lt;目标列表达式&gt;[,&lt;目标列表达式&gt;]…</p>
<p>from &lt;表名或视图名&gt; [,&lt;表名或视图名&gt;…]|(&lt;select语句&gt;)[AS]&lt;别名&gt;</p>
<p>[where&lt;条件表达式&gt;]</p>
<p>[group by &lt;列名1&gt;[having&lt;条件表达式&gt;]]</p>
<p>[order by&lt;列名2&gt;[asc|desc]]</p>
<p>整个select语句的含义是，根据where子句的条件表达式从from子句指定的基本表、视图或派生表中找出满足条件的元组，再按select子句中的目标列表达式选出元组中的属性值形成结果表。</p>
<p>如果由group by 子句，则将结果按&lt;列名1&gt;的值进行分组，该属性列值相等的元组为一组。通常会在每组中作用聚集函数。如果 group by子句带having短语，则只有满足指定条件的组才予以输出。</p>
<p>如果有order by子句，则结果表还有按&lt;列名2&gt;的值升序或降序排序。</p>
<p>select语句既可以完成简单的单表查询，也可以完成复杂的连接查询和嵌套查询。</p>
</li>
<li><p>单表查询</p>
<ol>
<li><p>选择表中的若干列</p>
<ul>
<li><p>查询指定列：如select Sno，Sname from Student。各个列的顺序可以与表中的顺序不一致</p>
</li>
<li><p>查询全部列：如select * from Student</p>
</li>
<li><p>查询经过计算的值：select 子句的&lt;目标列表达式&gt;不仅可以使表中的属性列，也可以是表达式。如：select Sname，‘Year of Birth：’，2014-Sage BIRTHDAY from Student</p>
</li>
</ul>
</li>
<li><p>选择表中的若干元组</p>
<ul>
<li><p>消除取值重复的行</p>
<p>两个本科并不完全相同的元组在投影到指定的某些列上后，可能会变成相同的行。可以使用distinct消除他们。</p>
<p>如：select distinct Sno from SC</p>
</li>
<li><p>查询满足条件的元组</p>
<p>查询满足条件的元组可以通过where子句实现。where子句常用的查询条件</p>
<ol>
<li><p>比较大小</p>
</li>
<li><p>确定范围：谓词between…and…和not between…and…可以用来查找属性值在(或不在)指定范围内的元组，其中<strong>between后是范围的下限(即低值)，and后是范围的上限(即高值)。</strong></p>
</li>
<li><p>字符匹配</p>
<p>谓词like可以用来进行字符串的匹配。其一般语法格式如下：</p>
<p>[not] like ‘&lt;匹配串&gt;’ [escape’&lt;换码字符&gt;’]</p>
<p>其含义是查找指定的属性列值与&lt;匹配串&gt;相匹配的元组。&lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符%和_。其中：</p>
<p>%(百分号)代表任意长度(长度可以为0)的字符串。例如a%b表示以a开头，以b结尾的任意长度的字符串。</p>
<p>_(下横线)代表任意单个字符</p>
<p><strong>如果用户要查询的字符串本身就含有通配符%或_,这是就要使用escape ‘&lt;换码字符&gt;’ 短语对通配符进行转义了。</strong></p>
</li>
<li><p>涉及空值的查询</p>
<p>IS和NOT IS</p>
</li>
<li><p>多重条件查询</p>
<p>AND 和 OR</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>order by子句</p>
<p>用户可以用order by子句对查询结果按照一个或多个属性列的升序(asc)或降序(desc)排列，默认值为升序。</p>
<p>对于空值，排序时显示的次序由具体系统实现来决定。例如按升序排，含空值的元组最后显示；按降序排，空值的元组则最先显示。各个系统的实现可以不同，只要保持一致就行。</p>
</li>
<li><p>聚集函数</p>
<p>为了进一步方便用户，增强检索功能，SQL提供了许多聚集函，主要有：</p>
</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">聚集函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">count(*)</td>
<td>统计元组个数</td>
</tr>
<tr>
<td style="text-align:center">count([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>统计一列中值的个数</td>
</tr>
<tr>
<td style="text-align:center">sum([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>计算一列值的总和(此列必须是数值型)</td>
</tr>
<tr>
<td style="text-align:center">sum([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>计算一列值的平均值(此列必须是数值型)</td>
</tr>
<tr>
<td style="text-align:center">max([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>求一列值中的最大值</td>
</tr>
<tr>
<td style="text-align:center">min([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>求一列值中的最小值</td>
</tr>
</tbody>
</table>
<p>   如果指定distinct短语，则表示在计算时要取消指定列中的重复值。如果不指定distinct短语或指定all短语(all为默认值)，则表示不取消重复值。</p>
<p>  <strong>当聚集函数遇到空值时，除count(*)外，都跳过空值而只处理非空值。聚集函数只能用于select子句和group by中的having子句。</strong></p>
<ol start="5">
<li><p>group by子句</p>
<p>group by子句将查询结果按某一列或多列的值分组，值相等的为一组。</p>
<p>对查询结果分组的目的是为了细化聚集函数的作用对象。如果未对查询结果分组，聚集函数将作用于整个查询结果。分组后聚集函数将作用于每一个组，即每一组都有一个函数值。</p>
<p>例子：见课本P99 例3.48</p>
</li>
</ol>
<ul>
<li><p>连接查询</p>
<p>若一个查询同时涉及两个以上的表，则称之为连接查询。连接查询是关系数据库中最主要的查询，包括等值连接查询、自然连接查询、非等值连接查询、自身连接查询、外连接查询和复合条件连接查询等。</p>
<ol>
<li><p>等值与非等值连接查询</p>
<ul>
<li><p>连接查询的where子句中用来连接两个表的条件称为<strong>连接条件或连接谓词</strong>其一般格式为</p>
<p>[&lt;表名1&gt;.]&lt;列名1&gt;&lt;比较运算符&gt;[&lt;表名2&gt;.]&lt;列名2&gt;</p>
<p>此外连接谓词还可以使用下面形式：</p>
<p>[&lt;表名1&gt;.]&lt;列名1&gt; between [&lt;表名2&gt;.]&lt;列名2&gt; and [&lt;表名3&gt;.]&lt;列名3&gt;</p>
<p><strong>当连接运算符为=时，称为等值连接。使用其他运算符称为非等值连接。</strong></p>
<p>连接谓词中的列名称为连接字段。连接条件中的各连接字段类型必须是可比的，但名字不必相同。</p>
</li>
<li><p>关系数据库管理系统执行该连接操作的一种可能过程是：首先在表Student中找到第一个元组，然后从头开始扫描SC表，逐一查找与Student第一个元组的Sno相等的SC元组，找到后就将Student中的第一个元组与该元组拼接起来，形成结果表中的一个元组。SC全部查找完后，再找Student中第二个元组，然后再从头开始扫描SC，逐一查找满足连接条件的元组，找到后就将Student中的第二个元组与该元组拼接起来，形成结果表中一个元组。重复以上操作。<strong>这就是嵌套循环连接算法的基本思想。</strong></p>
</li>
<li><p>如果在SC表Sno上建立了索引的化，就不用每次全表扫描SC表了，而是根据Sno值通过索引找到相应的SC元组。用索引查询SC中满足条件的元组一般会比全表扫描快。若在等值连接中<strong>把目标列中重复的属性列去掉则为自然连接。</strong></p>
</li>
<li><p>一条SQL语句可以同时完成选择和连接查询，这时where子句是由连接谓词和选择谓词组成的复合条件。</p>
</li>
</ul>
</li>
<li><p>自身连接</p>
<p>连接操作不仅可以在两个表之间进行，也可以是一个表与其自己进行连接，称为表的<strong>自身连接。</strong>例：select FIRST.Cno，SECOND.Cpno</p>
<p>​                from Course FIRST,Course SECOND</p>
<p>​                where FIRST.Cpno = SECOND.Cno</p>
</li>
<li><p>外连接</p>
<p>若某个学生没有选课，<strong>仍把Student的悬浮元组保存在结果关系中</strong>，而在SC表的属性上填空值NULL，这时就需要使用外连接。</p>
<p><strong>左外连接</strong>列出左边关系中所有的元组，<strong>右外连接</strong>列出右边关系中所有的元组。</p>
</li>
<li><p>多表连接</p>
<p>连接操作处理可以是<strong>两表连接</strong>、一个表与其自身连接外，还可以是两个以上的表进行连接，猴子通常称为<strong>多表连接</strong>。</p>
</li>
</ol>
</li>
<li><p>嵌套查询</p>
<p>在SQL语言中，<strong>一个select-from-where语句称为一个查询块</strong>。将一个查询块嵌套在另一个查询块的where子句或having短语的条件中的查询称为嵌套查询。上层的查询块称为外层查询或父查询，下层查询块称为内层查询或子查询。</p>
<p>SQL语言允许多层嵌套查询，即一个子查询中还可以嵌套其他子查询。需要特别指出的是，<strong>子查询的select语句中不能使用order by子句</strong>，order by子句只能对最终查询结果排序。</p>
<p>嵌套查询使用户可以用多个简单查询构成复杂的查询，从而增强SQL的查询能力。以层层嵌套的方式来构造程序正是SQL中”结构化“的含义所在。</p>
<ol>
<li><p>带有in谓词的子查询</p>
<p>子查询的查询条件不依赖于父查询，称为<strong>不相关子查询</strong></p>
<p>实现同一个查询请求可以有多种方法，当然不同的方法其执行效率可能会有差别，甚至会差别很大。这就是数据库编程人员应该掌握的数据库性能调优技术。</p>
<p>有些嵌套查询可以用连接运算代替，有些是不能替代的。</p>
<p>查询的查询条件不依赖于父查询，这类子查询称为不相关子查询。不相关子查询是较简单的一类子查询。<strong>如果子查询的查询条件依赖于父查询，这类子查询称为相关子查询，整个查询语句称为相关嵌套查询语句。</strong></p>
</li>
<li><p>带有比较运算符的子查询</p>
<p><img src="\images\相关子查询.jpg" alt="相关子查询"></p>
<p>x是表SC的别名，又称为元组变量，可以用来表示SC的元组。内层查询是求一个学生所有选修课程平均成绩的，至于是哪个学生的平均成绩要看<strong>参数x.Sno的值，而该值是与父查询相关的，因此这类查询称为相关子查询。</strong></p>
<p><strong>求解相关子查询不能像求解不相关子查询那样一次将子查询求解出来，然后求解父查询。</strong>内层查询由于与外层查询有关，因此必须反复求值。</p>
</li>
<li><p>带有any(some) 或 all 谓词的子查询</p>
<p>子查询返回单值时可以用比较运算符，但返回多值时要用any(有的系统用some)或all谓词修饰符。而使用any或all谓词时则必须同时使用比较运算符。</p>
<ul>
<li><em>&gt;any  大于子查询结果中的某个值</em></li>
<li><em>&gt;all  大于子查询结果中的所有值</em></li>
</ul>
<p>例子见课本P107 例3.58</p>
<p>例子中的查询也可以用聚集函数来实现，事实上，用聚集函数实现子查询通常比直接用any或all查询效率要高。</p>
<p><img src="\images\any与all和聚集函数对应关系表.jpg" alt="any与all和聚集函数对应关系表"></p>
</li>
<li><p>带有exists谓词的子查询</p>
<ul>
<li><p>exists代表存在量词∃。带有exists谓词的子查询不返回任何数据，只产生逻辑真值”true”或逻辑假值”false”。</p>
<p>例子：课本P109 例3.60</p>
</li>
<li><p>使用存在量词exists后，若内层查询结果非空，则外层的where子句返回真值，否则返回假值。</p>
</li>
<li><p>由exists引出的子查询，其目标列表达式通常都用*，因为带exists的子查询只返回真值或假值，给出列名无实际意义。</p>
</li>
<li><p>与exists谓词相对应的是not exists谓词。使用存在量词not exists后，若内层查询结果为空，则外层的where子句返回真值，否则返回假值。</p>
</li>
<li><p><strong>一些带exists 或 not exists谓词的子查询不能被其他形式的子查询等价替换，但所有带in谓词、比较运算符、any和all谓词的子查询都能用带exists谓词的子查询等价替换。</strong></p>
</li>
<li><p>SQL中没有全称量词，但是可以把带有全称量词的谓词转换为等价的带有存在量词的谓词</p>
<p>例子：课本P110 例3.62、3.63</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>集合查询</p>
<p>select 语句的查询结果是元组的集合，所以多个select语句的结果可进行集合操作。<strong>集合操作主要包括并操作union、交操作intersect和差操作except。</strong></p>
<p><em>使用union将多个查询结果合并起来时，系统会自动去掉重复元组。如果要保留重复元组则用union all操作符。</em></p>
</li>
<li><p>基于派生表的查询</p>
<p>子查询不仅可以出现在where子句中，还可以出现在from子句中，这时子查询生成的临时派生表成为主查询的查询对象。</p>
<p>select Sno,Cno</p>
<p>from SC,(select Sno,Avg(Grade) from SC group by Sno) as Avg_sc(avg_sno,avg_grade)</p>
<p>where SC.Sno = Avg_sc.avg_sno and SC.Grade &gt;= Avg_grade</p>
<p>这里from子句中的子查询将生成一个派生表Avg_sc。该表由avg_sno和avg_grade两个属性组成，记录了每个学生的学号及平均成绩。主查询将SC表与Avg_sc按学号相等进行连接，选出选修课成绩大于其平均成绩的课程号。</p>
<p><strong>通过from子句生成派生表时，as关键字可以省略，但必须为派生关系指定一个别名。</strong></p>
</li>
<li><p>select 语句的一般格式：</p>
<p>select [ALL|DISTINCT]&lt;目标列表达式&gt;[别名][,&lt;目标列表达式&gt;[别名]]…</p>
<p>from &lt;表名或视图名&gt;[别名][,&lt;表名或视图名&gt;[别名]]…|(<select 语句>)[as]&lt;别名&gt;</select></p>
<p>[where &lt;条件表达式&gt;]</p>
<p>[group by&lt;列名1&gt;[having1&lt;条件表达式&gt;]]</p>
<p>[order by&lt;列名2&gt;[asc|desc]]</p>
<ol>
<li><p>目标列表达式的可选格式</p>
<p><img src="\images\目标列表达式的可选格式.jpg" alt="目标列表达式的可选格式"></p>
</li>
<li><p>聚集函数的一般格式</p>
<p><img src="\images\聚集函数的一般格式.jpg" alt="聚集函数的一般格式"></p>
</li>
<li><p>where子句的条件表达式的可选格式</p>
<p><img src="\images\where子句的条件表达式的可选格式.jpg" alt="where子句的条件表达式的可选格式"></p>
</li>
</ol>
</li>
</ul>
<h3 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h3><p>数据更新操作有三种:向表中添加若干行数据、修改表中的数据和删除表中的若干行数据。</p>
<ul>
<li><p>插入数据</p>
<ol>
<li><p>插入元组</p>
<p>insert into &lt;表名&gt;[(&lt;属性列1&gt;[,&lt;属性列2&gt;]…)]values(&lt;常量1&gt;[,常量2]…)</p>
<p>在into子句中指出了表名Student，并指出了新增加的元组在哪些属性上要赋值，属性的顺序可以与create table中的顺序不一样。values子句对新元组的各属性赋值，字符串常数要用单引号(英文符合)括起来。</p>
<p>例：</p>
<p>insert into SC(Sno,Cno) values(‘201215128’,’1’)</p>
<p><strong>关系数据库管理系统将在新插入记录的Grade列上自动的赋空值。</strong></p>
<p>或 insert into SC values(‘201215128’,’1’,NULL)</p>
<p><strong>因为没有指出SC的属性名，在Grade列上要明确给出空值。</strong></p>
</li>
<li><p>插入子查询结果</p>
<p>插入子查询结果的insert 语句格式为</p>
<p>insert into &lt;表名&gt;[(&lt;属性列1&gt;[,&lt;属性列2&gt;…]） 子查询；</p>
</li>
</ol>
</li>
<li><p>修改数据</p>
<p>修改操作又称为更新操作，其语句的一般格式为</p>
<p>update &lt;表名&gt;</p>
<p>set &lt;列名&gt;=&lt;表达式&gt;[，&lt;列名&gt;=&lt;表达式&gt;]…</p>
<p>[where &lt;条件&gt;]</p>
<p>其功能是修改指定表中满足where子句条件的元组。其中set子句给出&lt;表达式&gt;的值用于取代相应的属性列值。如果省略where子句，则表示要修改表中的所有元组。</p>
<ol>
<li><p>修改某一个元组的值</p>
<p>例3.73 将学生201215121的年龄改为22岁</p>
<p>update Student set Sage=22 where Sno=’201215121’</p>
</li>
<li><p>修改多个元组的值</p>
<p>例 3.74 将所有学生的年龄增加1岁</p>
<p>update Student set Sage=Sage+1</p>
</li>
<li><p>带子查询的修改语句</p>
<p>子查询也可以嵌套在update语句中，用以构造修改的条件</p>
<p>例 3.75 将计算机科学系全体学生的成绩置零。</p>
<p>update SC set Grade=0</p>
<p>where Sno in(select Sno from Student where Sdept=’CS’)</p>
</li>
</ol>
</li>
<li><p>删除数据</p>
<p>删除语句的一般格式为</p>
<p>delete from &lt;表名&gt; [where &lt;条件&gt;]；</p>
<ol>
<li>删除某一个元组的值</li>
<li>删除多个元组的值</li>
<li>带子查询的删除语句</li>
</ol>
</li>
</ul>
<h3 id="空值的处理"><a href="#空值的处理" class="headerlink" title="空值的处理"></a>空值的处理</h3><p>所谓的空值就是”不知道”或”不存在”或”无意义”的值。 SQL语言中允许某些元组的某些属性在一定情况下取空值。</p>
<p>一般有以下几种情况：</p>
<ul>
<li>该属性应该有一个值，但目前不知道它的具体值。</li>
<li>该属性不应该有值。</li>
<li>由于某种原因不便于填写。</li>
</ul>
<ol>
<li><p>空值的产生</p>
<p>插入和连接会产生空值。空值的关系运算也会产生空值。</p>
</li>
<li><p>空值的判断</p>
<p>判断一个属性的值是否为空值，用 IS NULL或IS NOT NULL来表示。</p>
</li>
<li><p>空值的约束条件</p>
<p>属性定义(或者域定义)中有 NOT NULL约束条件的不能取空值，码属性不能取空值。</p>
</li>
<li><p>空值的算术运算、比较运算和逻辑运算</p>
<p>空值与另一个值(包括另一个空值)的算术运算的结果为空值，空值与另一个值(包括另一个空值)的比较运算的结果为unknow。<strong>有了unknown后，传统的逻辑运算中二值(true,false)逻辑就扩展成了三值逻辑。</strong></p>
<p><img src="\images\逻辑运算符真值表.jpg" alt="逻辑运算符真值表"></p>
</li>
</ol>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是从一个或几个基本表(或视图)导出的表。它与基本表不同，是一个虚表。数据库中只存放视图的定义，二不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以一旦基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。视图一经定义，就可以和基本表一样被查询、被删除。</p>
<ul>
<li><p>定义视图</p>
<ol>
<li><p>建立视图</p>
<p>SQL语言用create view命令建立视图，其一般格式为</p>
<p>create view &lt;视图名&gt;[(&lt;列名&gt;[,&lt;列名&gt;]…)]</p>
<p>as &lt;子查询&gt;</p>
<p>[with check option]</p>
<p>其中，子查询可以是任意的select语句，是否可以含有order by子句和distinct短语，则取决于具体系统的实现。</p>
<p><strong>with check option 表示对视图进行update、insert和delete操作时要保证更新、插入或删除的行满足视图定义中的谓词条件(即子查询中的条件表达式)。</strong></p>
<p>组成视图的属性列名或者全部省略或者全部指定，没有第三种选择。如果省略了视图的各个属性列名，则隐含该视图由子查询中select子句目标列中的诸字段组成。但在下列三种情况下必须明确指定组成视图的所有列名:</p>
<ol>
<li>某个目标列不是单纯的属性名，而是聚集函数或列表达式</li>
<li>多表连接时选出了几个同名列作为视图的字段</li>
<li>需要在视图中为某个列启用新的更合适的名字</li>
</ol>
<ul>
<li>关系数据库管理系统执行create view语句的结果<strong>只是把视图的定义存入数据字典，并不执行其中的select语句。</strong>只是在对视图查询时，才按视图的定义从基本表中将数据查出。</li>
<li>由于在定义IS_Student视图时加上了with check option子句，以后对该视图进行插入、修改和删除操作时，<strong>关系数据库管理系统会自动加上Sdept=’IS‘的条件</strong>。P122 例：3.85</li>
<li>若一个视图是<strong>从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码，则称这类视图为行列子集视图。</strong></li>
<li>视图不仅可以建立在一个或多个基本表上，也<strong>可以建立在一个或多个已定义好的视图上，或建立在基本表与视图上。</strong></li>
<li>定义基本表时，为了减少数据库中的冗余数据，表中只存放基本数据，由基本数据经过各种计算派生吃的数据一般是不存储的。由于视图中的数据并不实际存储，所以定义视图时可以根据应用的需要设置一些派生属性列。这些派生属性由于在基本表中并不实际存在，也称它们为虚拟列。<strong>带虚拟列的视图也称为带表达式的视图。</strong>例 P123 例3.88</li>
</ul>
</li>
<li><p>删除视图</p>
<ul>
<li>该语句的格式为 drop view &lt;视图名&gt;[cascade];</li>
<li>视图删除后视图的定义将从数据字典中删除。如果该视图上还导出了其他视图，则使用cascade级联删除语句把该视图和由它导出的所有视图一起删除。</li>
<li>基本表删除后，由该基本表导出的所有视图均无法使用，但是视图的定义没有从字典中清除。删除这些视图定义需要显式的使用drop view语句。</li>
</ul>
</li>
</ol>
</li>
<li><p>查询视图</p>
<ul>
<li>关系数据库管理系统执行对视图的查询时，首先进行有效性检查，检查查询中涉及的表、视图等是否存在。如果存在，则<strong>从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后再执行修正了的查询。这一转换过程称为视图消解。</strong></li>
<li>目前多数关系数据库系统对行列子集视图的查询均能进行正确转换。但对非行列子集视图的查询就不一定能做转换了，因此这类查询应该直接对基本表进行。</li>
<li>但<strong>定义视图并查询视图与基于派生表的查询是有区别的。</strong>视图一旦定义，其定义将永久保存在数据字典中，之后的所有查询都可以直接引用该视图。而<strong>派生表只是在语句执行时临时定义，语句执行后该定义即被删除。</strong></li>
</ul>
</li>
<li><p>更新视图</p>
<ul>
<li>更新视图是指通过视图来插入、删除和修改数据。</li>
<li>由于视图是不实际存储数据的虚表，因此对视图的更新最终要转换为对基本表的更新。像查询视图那样，对视图的更新操作也是通过视图消解，转换为对基本表的更新操作。</li>
<li>为防止用户通过视图对数据进行增加、删除、修改时，有意无意的对不属于视图范围内的基本表数据进行操作，可在定义视图时加上with check option子句。这样在视图上增、删、改数据时，关系数据库管理系统会检查视图定义中的条件，若不满足条件则拒绝执行该操作。</li>
<li>在关系数据库中，并不是所有的视图都是可更新的，因为有些视图的更新不能唯一的有意义的转换成对相应基本表的更新。</li>
<li>一般的，行列子集视图是可更新的。除行列子集视图外，有些视图理论上是可更新的，但他们的确切特征还是尚待研究的课题。还有些视图从理论上就是不可更新的。</li>
<li>目前，各个关系数据库管理系统一般都只允许对行列子集视图进行更新，而且各个系统对视图的更新还有更进一步的规定。由于各系统实现方法上的差异，这些规定也不尽相同。</li>
<li>一个不允许更新的视图上定义的视图也不允许更新，不可更新的视图与不允许更新的视图是两个不同的概念。</li>
</ul>
</li>
<li><p>视图的作用</p>
</li>
</ul>
<p>视图最终是定义在基本表之上的，对视图的一起操作最终也要转换为对基本表的操作。</p>
<ol>
<li><p>视图能够简化用户的操作</p>
<ol start="2">
<li><p>视图能够是用户以多种角度看待同一组数据</p>
</li>
<li><p>视图对重构数据库提供了一定程度的逻辑独立性</p>
<p>这样尽管数据库的逻辑结构改变了(变为SX和SY两个表)，但应用程序不必修改，因为新建立的视图定义为用户原来的关系，使用户的外模式保持不变，用户的应用程序通过视图仍然能够查找数据。</p>
</li>
<li><p>视图能够对机密数据提供安全保护</p>
</li>
<li><p>适当利用视图可以更清晰的表达查询</p>
</li>
</ol>
</li>
</ol>
<h2 id="第四章-数据库安全性"><a href="#第四章-数据库安全性" class="headerlink" title="第四章 数据库安全性"></a>第四章 数据库安全性</h2><h3 id="数据库安全性概述"><a href="#数据库安全性概述" class="headerlink" title="数据库安全性概述"></a>数据库安全性概述</h3><p>数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏。</p>
<ul>
<li><p>数据库的不安全因素</p>
<ol>
<li>非授权用户对数据库的恶意存取和破坏</li>
<li>数据库中重要或敏感的数据被泄漏</li>
<li>安全环境的脆弱性</li>
</ol>
</li>
<li><p>安全标准简介</p>
<p>为满足全球IT市场上互认标准化安全评估结果的需要，CTCPEC、FC、TCSEC和ITSEC的发起组织于1993年起开始联合行动，解决标准中概念和技术上的差异，将各自独立的准则集合成一组单一的、能被广泛使用的IT安全准则，这一行动被称为通用准则(CC)项目。项目发起组织的代表建立了专门的委员会来开发通用准则，经历多次讨论和修订，CCV2.1版于1999年被ISO采用为国际标准，<strong>2001年被我国采用为国家标准。</strong></p>
<p><strong>TCSEC又称桔皮书。</strong>1991年4月，美国国家计算机安全中心颁布了《可信计算机系统评估准则关于可信数据库系统的解释》(即紫皮书)，将TCSEC扩展到数据库管理系统。TCSEC/TDI中定义了数据库管理系统的设计与实现中需满足和用以进行安全性级别评估的标准，从4个方面来描述安全性级别划分的指标，即安全策略、责任、保证和文档。每个方面又细分为若干项。</p>
<p><img src="\images\信息安全标准的发展简史.jpg" alt="信息安全标准的发展简史"></p>
<p>根据计算机系统对各项指标的支持情况，TCSEC/TDI将系统划分为4组7个等级，依次是D、C(C1,C2)、B(B1,B2,B3)、A(A1),按系统可靠或可信程度逐渐增高</p>
<p><img src="\images\安全级别划分.jpg" alt="TCSEC/TDI安全级别划分"></p>
<ul>
<li>D级：该级是最低级别。保留D级的目的是为了将一切不符合更高标准的系统统统归于D组。如DOS就是操作系统中安全标准为D级的典型例子，它具有操作系统的基本功能，如文件系统、进程调度等，但在安全性方面几乎没有什么专门的机制来保障。</li>
<li>C1级：该级只提供了非常初级的自主安全保护，能够实现对用户和数据的分离，进行<strong>自主存取控制(DAC)</strong>,保护或限制用户权限的传播。现有的商业系统往往稍作改进即可满足要求。</li>
<li>C2级：该级实际上是安全产品的最低档，提供受控的存取保护，即将C1级的DAC进一步细化，以个人身份注册负责，并实施审计和资源隔离。达到C2级的产品在其名称中往往不突出”安全”这一特色，如操作系统中的window 2000、数据库产品中的Oracle 7等。</li>
<li>B1级：标记安全保护。对系统的数据加以标记，并<strong>对标记的主体和客体实施强制存取控制(MAC)以及审计等安全机制。B1级别的产品才被认为是真正意义上的安全产品，</strong>满足此级别的产品前一般多冠以”安全”或可信的字样，作为区别于普通产品的安全产品出售。</li>
<li>B2级：结构化保护。建立形式化的安全策略模型，并对系统内的所有主体和客体实施DAC和MAC。</li>
<li>B3级：安全域。该级的TCB必须满足访问监控器的要求，审计跟踪能力更强，并提供系统恢复过程。</li>
<li>A1级：验证设计，即提供B3级保护的同时给出系统的形式化设计说明和验证，以确信各安全保护真正实现。</li>
</ul>
<p>CC评估保障即的划分</p>
<p><img src="/images/CC评估保证级(EAL" alt="CC评估保证级(EAL)的划分">的划分.jpg)</p>
<p><strong>粗略而言，TCSEC的C1和C2级分别相当于EAL2和EAL3；B1、B2和B3分别相当于EAL4、EAL5和EAL6；A1对应于EAL7。</strong></p>
</li>
</ul>
<h3 id="数据库安全性控制"><a href="#数据库安全性控制" class="headerlink" title="数据库安全性控制"></a>数据库安全性控制</h3><p>在一般计算机系统中，安全措施是一级一级层层设置的。</p>
<p>下面讨论与数据库有关的安全性，主要包括用户身份鉴别、多层存取控制、审计、视图和数据加密等安全技术。</p>
<p><img src="\images\计算机系统的安全模型.jpg" alt="计算机系统的安全模型"></p>
<ul>
<li><p>用户身份鉴别</p>
<ol>
<li>静态口令鉴别</li>
<li>动态口令鉴别</li>
<li>生物特征鉴别</li>
<li>智能卡鉴别</li>
</ol>
</li>
<li><p>存取控制</p>
<p>数据库安全最重要的一点就是确保只授权给有资格的用户访问数据库的权限，同时令所有未被授权的人员无法接近数据，这主要通过数据库系统的存取控制机制实现。</p>
<p><strong>存取控制机制主要包括定义用户权限和合法权限检查两部分。</strong></p>
<ol>
<li><p>定义用户权限，并将用户权限登记到数据字典中</p>
<p>用户对某一数据对象的操作权力称为权限。某个用户应该具有何种权限是个管理问题和政策问题，而不是技术问题。数据库管理系统的功能是保证这些决定的执行。为此，数据库管理系统必须提供适当的语言来定义用户权限，这些定义经过编译后存储在数据字典中，被称做安全规则活授权规则</p>
</li>
<li><p>合法权限检查</p>
<p>每当用户发送存取数据库的操作请求后(请求一般包括操作类型、操作对象和操作用户等信息)，数据库管理系统查找数据字典，根据安全规则进行合法权限检查，若用户的操作请求超出了定义的权限，系统将拒绝执行此操作。</p>
<p><strong>定义用户权限和合法权限检查机制一起组成了数据库管理系统的窜去控制子系统。</strong></p>
<p>C2级的数据库管理系统支持自主存取控制，B1级的数据库管理系统支持强制存取控制。</p>
<p>两类方法的简单定义：</p>
<ul>
<li>在自主存取控制方法中，用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可将其拥有的存取权限转授给其他用户。因此自主存取控制非常灵活。</li>
<li>在强制存取控制方法中，每一个数据库对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。对于任意一个对象，只有具有合法许可证的用户才可以存取。因此强制存取控制因此相对比较严格。</li>
</ul>
</li>
</ol>
</li>
<li><p>自主存取控制方法</p>
<p>大型数据库管理系统都支持自主存取控制，SQL标准也对自主存取控制提供支持，这主要通过SQL的GTANT语句和REVOKE语句来实现。</p>
<p><strong>用户权限是由两个要素组成的:数据库对象和操作类型。</strong>定义一个用户的存取权限就是要定义这个用户可以在哪些数据库对象上进行哪些类型的操作。在数据库系统中，<strong>定义存取权限称为授权</strong>。</p>
<p>在非关系系统中，用户只能对数据进行操作，存取控制的对象不仅有数据本身(基本表中的数据、属性列上的数据)，还有数据库模式(包括模式、基本表、视图和所有的创建等)</p>
</li>
<li><p><img src="/images/关系数据库系统中的存取权限.jpg" alt="关系数据库系统中的存取权限"></p>
</li>
<li><p>授权：授予与收回</p>
<p>SQL中使用GRANT和REVOKE语句向用户授予或收回对数据的操作权限。GRANT语句向用户授予权限，REVOKE语句收回以及授予用户的权限。</p>
<ol>
<li><p>GRANT</p>
<p>GRANT语句的一般格式为</p>
<p>GRANT &lt;权限&gt;[,&lt;权限&gt;]…</p>
<p>ON &lt;对象类型&gt;&lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]…</p>
<p>TO &lt;用户&gt;[,&lt;用户&gt;]…</p>
<p>[WITH GRANT OPTION]</p>
<p>其语义为：将对指定操作对象的指定操作权限授予指定的用户。发出该GRANT语句的可以是数据库管理员，也可以是该数据库对象创建者(即属主owner)，还可以是已经拥有该权限的用户。接受权限的用户可以是一个或多个具体用户，也可以是PUBLIC，即全体用户。</p>
<p>如果指定了 with grant option子句，则获得某种权限的用户还可以把这种权限再授予其他的用户。没有指定with grant option子句，则获得某种权限的用户只能使用该权限，不能传播该权限。</p>
<p>SQL标准允许具有with grant option的用户把相应权限或其子集传递授予其他用户，但不允许循环授权，即被授权者不能把权限再授回给授权者或其祖先。</p>
</li>
<li><p>REVOKE</p>
<p>授予用户的权限可以由数据库管理员或其他授权者用revoke 语句收回，revoke语句的一般格式为</p>
<p>REVOKE &lt;权限&gt;[,&lt;权限&gt;]…</p>
<p>ON &lt;对象类型&gt;&lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]…</p>
<p>FROM &lt;用户&gt;[,&lt;用户&gt;]…[cascade|restrict]</p>
<p>所有授予出去的权力在必要时又都可以用revoke语句收回。</p>
<p>可见，<strong>用户可以”自主“的决定将数据的存取权限授予何人、决定是否也将”授权“的权限授予别人。因此称这一的存取控制是自主存取控制。</strong></p>
</li>
</ol>
</li>
</ul>
<ol start="3">
<li><p>创建数据库模式的权限</p>
<p>GRANT和REVOKE语句向用户授予或收回对数据的操作权限。对创建数据库模式的一类的数据库对象的授权则由数据库管理员在创建用户时实现。</p>
<p>create user语句一般格式如下：</p>
<p>create user <username> [with][DBA|RESOURCE|CONNECT]</username></p>
<p>对create user语句说明如下：</p>
<ul>
<li><p>只有系统的超级用户才有权创建一个新的数据库用户</p>
</li>
<li><p>新创建的数据库用户有三种权限：connec他、resource和dba。</p>
</li>
<li><p>create user命令中如果没有指定创建的新用户的权限，默认该用户拥有connect权限。拥有connect权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登入数据库。由数据库管理员或其他用户授予它应由的权限，根据获得的授权情况他可以对数据库对象进行权限范围内的操作。</p>
</li>
<li><p>拥有resource权限的用户能创建基本表和视图，成为所创建对象的属主但不能创建新的用户。数据库对象的属主可以使用grant语句把该对象上的存取权限授予其他用户。</p>
</li>
<li><p>拥有DBA权限的用户是系统中的超级用户，可以创建新的用户、创建模式、创建基本表和视图等；DBA拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户。</p>
<p><img src="\images\权限与可执行的操作对照表.jpg" alt="权限与可执行的操作对照表"></p>
<p><em>注意：create user语句不上SQL标准，因此不同的关系数据库管理系统的语法和内容相差甚远。</em></p>
</li>
</ul>
</li>
</ol>
<ul>
<li>数据库角色</li>
</ul>
<p>数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合。</p>
<ol>
<li><p>角色的创建</p>
<p>创建角色的SQL语句格式是</p>
<p>create role &lt;角色名&gt;</p>
<p>刚刚创建的角色是空的，没有任何内容。可以用grant为角色授权。</p>
</li>
<li><p>给角色授权</p>
<p>grant &lt;权限&gt;[,&lt;权限&gt;]…</p>
<p>on &lt;对象类型&gt;对象名</p>
<p>to &lt;角色&gt;[,&lt;角色&gt;]…</p>
<p>数据库管理员和用户可以利用grant语句将权限授予某一个或几个角色。</p>
</li>
<li><p>将一个角色授予其他的角色或用户</p>
<p>grant &lt;角色1&gt;[,&lt;角色2&gt;]…</p>
<p>to &lt;角色3&gt;[,&lt;用户1&gt;]…</p>
<p>[with admin option]</p>
<p>该语句把角色授予某用户，或授予另一角色。这样，一个角色所拥有的权限就是授予它的全部角色所包含的权限的总和。</p>
<p>授予者或者是角色的创建者忙活着拥有在这个角色上的admin option。</p>
<p>如果指定了with admin option子句，则获得某种权限的角色或用户还可以把这种权限再授予其他的角色</p>
<p>一个角色包含的权限包括直接授予这个角色的全部权限加上其他角色授予这个角色的全部权限。</p>
</li>
<li><p>角色权限的收回</p>
<p>revoke &lt;权限&gt;[,&lt;权限&gt;]…</p>
<p>on &lt;对象类型&gt;&lt;对象名&gt;</p>
<p>from &lt;角色&gt;[,&lt;角色&gt;]…</p>
<p>用户可以收回角色的权限，从而修改角色拥有的权限。</p>
<p>revoke 动作的执行者或者是角色的创建者，或者拥有在这个(些)角色上的ADMIN OPTION.</p>
</li>
</ol>
<ul>
<li><p>强制存取控制方法</p>
<p>在强制存取控制中，数据库管理系统所管理的全部视图被分为主体和客体两大类。</p>
<p>主体是系统中的获得实体，既包括数据库该你了系统所管理的实际用户，也包括代表用户的各进程。客体是系统中的被动实体，是受主体操作的，包括文件、基本表、索引、视图等。对于主体和客体，数据库管理系统为他们每个实例指派一个，敏感度标记。</p>
<p>敏感度标记被分成若干级别，例如绝密(TS)、机密(S)、可信(C)、公开(P)等。密级的次序是TS&gt;=S&gt;=C&gt;=P。主体的敏感度标记称为许可证级别，客体的敏感度标记称为密级。强制存取控制机制就是通过对比主体的敏感度标记和客体的敏感度标记，最终确定主体是否能够存取客体。</p>
<p>当某以用户以标记label注册入系统时，系统要求他对任何客体的存取必须遵循如下规则：</p>
<ol>
<li><p>仅当主体的许可证级别大于或等同于客体的密级时，该主体才能读取相应的客体。</p>
</li>
<li><p>仅当主体的许可证级别小于或等同于客体的密级时，该主体才能写相应的客体。</p>
<p>如果违反了规则2，就有可能把数据的密级从高流向低，造成数据的泄漏。</p>
</li>
</ol>
<p>强制存取控制是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级要求的用户才可以操作数据，从而提供了更高级别的安全性。</p>
</li>
</ul>
<h3 id="视图机制"><a href="#视图机制" class="headerlink" title="视图机制"></a>视图机制</h3><p>可以为不同的用户定义不同的视图,把数据对象限制在一定的范围内。也就是说，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动对数据提供一定程度的安全保护。</p>
<p>视图机制间接的实现支持存取谓词的用户权限定义。</p>
<h3 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h3><p>审计功能把用户对数据库的所有操作自动记录下来，放入审计日志中。审计员可以利用审计日志监控数据库中的各种行为，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。</p>
<ol>
<li><p>审计事件</p>
<p>审计事件一般有多个类别</p>
<p>服务器事件:审计数据库服务器发生的事件，包含数据库服务器的启动、停止、数据库服务器配置文件的重新加载。</p>
<p>系统权限：对系统拥有的结构或模式对象进行操作的审计，要求该操作的权限是通过系统权限获得的。</p>
<p>语句事件：对SQL语句，如DDL、DML、DQL及DCL语句的审计</p>
<p>模式对象事件：对特定模式对象上进行的select 或dml操作的审计。模式对象包括表、视图、存储过程、函数等。模式对象不包括依附于表的索引、约束、触发器、分区表等。</p>
</li>
<li><p>审计功能</p>
<p>审计功能主要包括以下几个方面：</p>
<ul>
<li>基本功能，提供多种审计查阅方式：基本的、可选的、有限的，等等。</li>
<li>提供多套审计规则，审计规则一般在数据库初始化时设定，以方便审计员管理。</li>
<li>提供审计分析和报表功能</li>
<li>审计日志管理功能</li>
<li>系统提供查询审计设置及审计记录信息的专门视图。</li>
</ul>
</li>
<li><p>audit语句和noaudit语句</p>
<p>audit语句用来设置审计功能，noaudit语句则取消审计功能。</p>
<p>审计一般可以分为用户级审计和系统级审计。</p>
<p>例：audit alter，update on SC和noaudit alter，update on SC</p>
<p>审计设置以及审计日志一般都存储在数据字典中。必须把审计开关打开，才可以在系统表SYS_AUDITTRAIL中查看到审计信息。</p>
<p>数据库安全审计系统提供了一种事后检查的安全机制。</p>
</li>
</ol>
<h3 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h3><p>加密的基本思想是根据一定的算法将原始数据——明文变换为不可直接识别的格式——密文，从而使得不知道界面算法的人无法获知数据的内容.</p>
<ol>
<li><p>存储加密</p>
<p>对于存储加密，一般提供透明和非透明两种存储加密方式。透明存储加密是内核级加密保护方式，对用户完全透明；非透明存储加密则是通过多个加密函数实现的。</p>
</li>
<li><p>传输加密</p>
<p>常见的传输加密方式如链路加密和端到端加密</p>
<p>安全套接层协议SSL，端到端</p>
<p>实现思路包括：</p>
<ol>
<li><p>确认通信双方端点的可靠性</p>
</li>
<li><p>协商加密算法和密钥</p>
</li>
<li><p>可信数据传输</p>
</li>
</ol>
</li>
</ol>
<h3 id="其他安全性保护"><a href="#其他安全性保护" class="headerlink" title="其他安全性保护"></a>其他安全性保护</h3><p>在自主存取控制和强制存取控制之外，还有推理控制以及数据库应用中隐蔽信道和数据隐私保护等技术。</p>
<ul>
<li>推理控制除了的是强制存取控制为解决的问题。数据库推荐控制机制用来避免用户利用其能够访问的数据推知更高密级的数据。</li>
<li>隐蔽信道处理内容也是强制存取控制为解决的问题。</li>
<li>数据隐私成为数据库应用中新的数据保护模式。所谓数据隐私是控制不愿被他人知道或他人不便知道的个人数据的能力。</li>
</ul>
<hr>
<h2 id="第五章-数据库完整性"><a href="#第五章-数据库完整性" class="headerlink" title="第五章 数据库完整性"></a>第五章 数据库完整性</h2><p>数据库的完整性是指数据的正确性和相容性</p>
<p>为维护数据库的完整性，数据库管理系统必须能够实现以下功能：</p>
<ol>
<li>提供定义完整性约束条件的机制</li>
<li>提供完整性检查的方法</li>
<li>进行违约处理</li>
</ol>
<p>关系数据库管理系统使得完整性控制成为其核心支持的功能，从而能够为所有用户和应用提供一致的数据库完整性。</p>
<h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><ul>
<li><p>定义实体完整性</p>
<p>关系模型的实体完整性在create table中用primary key定义。对单属性构成的码有两种说明方法，一种是定义为劣迹约束条件，另一种是定义为标记约束条件。对于多个属性构成的码只有一种说明方法，即定义为表级约束条件。</p>
</li>
<li><p>实体完整性检查和违约处理</p>
<p>用primary key短语定义了关系的主码后，每当用户程序对级别表插入一条记录或对主码列进行更新操作时，关系数据库管理系统将按照实体完整性规则进行自动检查。</p>
<ol>
<li>检查主码值是否唯一，如果不唯一则拒绝插入或修改。</li>
<li>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改。</li>
</ol>
<p>全表扫描是十分好事都。为了避免对基本表进行全表扫描，关系数据库管理系统一般都在主码上自动建立一个索引。</p>
</li>
</ul>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><ul>
<li><p>定义参照完整性</p>
<p>关系模型的按照完整性在create table中用foreign key短语定义哪些列为外码，用references短语芝麻这些外码参照哪些表的主码。</p>
</li>
<li><p>参照完整性检查和违约处理</p>
<p>参照完整性将两个表中的相应元组联系起来了。因此，对被参照表和参照表进行增、删、改操作时有可能破坏参照完整性，必须进行检查以保证这两个表的相容性。</p>
<p><img src="/images/可能破坏参照完整性的情况及违约处理.jpg" alt="可能破坏参照完整性的情况及违约处理"></p>
<p>当上述的不一致发生时，系统可以采用以下策略加以处理</p>
<ol>
<li><p>拒绝(no action)执行：不允许该操作。该策略一般设置为默认策略。</p>
</li>
<li><p>级联(cascade)操作：当删除或修改被参照表中的一个元组导致与参照表的不一致时，删除或修改参照表中的所有不一致的元组。</p>
</li>
<li><p>设置为空值：当删除或修改被参照表的一个元组时造成了不一致，则将参照表中所有曹操不一致的元组的对应属性设置为空值。</p>
</li>
</ol>
</li>
</ul>
<h3 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h3><ul>
<li><p>属性上的约束条件</p>
<ol>
<li><p>属性上约束条件的定义</p>
<ul>
<li>列值非空(not null)</li>
<li>列值唯一(unique)</li>
<li>检查列值是否满足一个条件表达式(check短语)</li>
</ul>
</li>
<li><p>属性上约束条件的检查和违约处理</p>
<p>不满足条件拒绝执行</p>
</li>
</ol>
</li>
<li><p>元组上的约束条件</p>
<ol>
<li><p>元组上约束条件的定义</p>
<p>与属性上约束条件的定义类似，在create table语句中可以用check 短语定义元组上的约束条件，即元组级的限制。同属性值限制相比，元组级的限制可以设置不同的属性之间的取值的相互约束条件。</p>
</li>
<li><p>属性上约束条件的检查和违约处理</p>
<p>不满足条件拒绝执行</p>
</li>
</ol>
</li>
</ul>
<h3 id="完整性约束命名子句"><a href="#完整性约束命名子句" class="headerlink" title="完整性约束命名子句"></a>完整性约束命名子句</h3><ol>
<li><p>完整性约束命名子句</p>
<p>constraint &lt;完整性约束条件名&gt;&lt;完整性约束条件&gt;</p>
<p>&lt;完整性约束条件&gt;包括not null、unique、primary key、foreign key、check等</p>
</li>
<li><p>修改表中的完整性限制</p>
<p>可以使用alter table语句修改表中的完整性限制</p>
<p>alter table Student drop constraint C4</p>
</li>
</ol>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>在SQL中可以使用数据定义语言中的create assertion语句，通过声明性断言来指定更具一般性的约束。可以定义设计多个表或聚集操作的笔记复制的完整性约束。任何断言不为真的都拒绝执行</p>
<ol>
<li><p>创建断言的语句格式</p>
<p>create assertion &lt;断言名&gt;<check 子句></check></p>
<p>每一断言都被赋予一个名字，<check 子句>中的约束条件与where子句的条件表达式类似。</check></p>
</li>
<li><p>删除断言的语句格式</p>
<p>drop assertion&lt;断言名&gt;</p>
</li>
</ol>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>触发器是用户定义在关系表上的一类由事件驱动的特殊过程。</p>
<ul>
<li><p>定义触发器</p>
<p>触发器又叫做事件-条件-动作规则。其一般格式为</p>
<p>create trigger &lt;触发器名&gt;</p>
<p>{before|after} &lt;触发器事件&gt; on &lt;表名&gt;</p>
<p>referencing  new|old  row as &lt;变量&gt;</p>
<p>for each{row|statement}</p>
<p>[when&lt;触发条件&gt;]&lt;触发动作体&gt;</p>
<p>各部分详细说明</p>
<ul>
<li>只有表的拥有者，即创建表的用户才可以在表上创建触发器，并且一个表上只能创建一定数量的触发器。触发器的具体数量由具体的关系数据库管理系统在设计时确定。</li>
<li>触发器名：触发器名可以保护模式名，也可以不包含模式名。同以模式下，触发器名必须是唯一的，并且触发器名与表名必须在同一模式下。</li>
<li>表名：触发器只能定义在基本表上，不能定义在视图上。当基本表的数据发生变化时，将激活定义在改表上相应触发事件的触发器，因此该表也称为触发器表。</li>
<li>触发事件：出发时间可以是insert、delete或update，也可以是这几个事件的组合，如insert or delete等，还可以是update of&lt;触发列，…&gt;即进一步指名修改哪些列时激活触发器。after/before是触发的时机。after表示在触发事件的操作执行之后激活触发器；before表示在触发事件的操作执行之前激活触发器。</li>
<li>触发器类型：触发器按照所触发动作的间隔尺寸可以分为行级触发器和语句级触发器。</li>
<li>触发条件：触发器被激活时，只有当触发条件为真时触发动作体才执行，否则触发动作体不执行。如果省略when触发条件，则触发动作体在触发器激活后立即执行。</li>
<li>触发动作体：触发动作体既可以是一个匿名PL/SQL过程块，也可以是对已创建存储过程的调用。</li>
</ul>
</li>
<li><p>激活触发器</p>
<p>触发器的执行是由触发事件激活，并由数据库服务器自动执行的。一个数据表上可能定义了多个触发器，如多个before触发器、多个after触发器等，同一个表上的多个触发器激活时遵循如下的执行顺序：</p>
<ol>
<li><p>执行该表上的before触发器</p>
</li>
<li><p>激活触发器的SQL语句</p>
</li>
<li><p>执行该表上的after触发器</p>
<p>对于同一个表的多个before(after)触发器，遵循“谁先创建谁先执行”的原则。</p>
</li>
</ol>
</li>
<li><p>删除触发器</p>
<p>删除触发器的SQL语法如下：</p>
<p>drop trigger &lt;触发器名&gt; on &lt;表名&gt;</p>
<hr>
</li>
</ul>
<h2 id="第六章-关系数据理论"><a href="#第六章-关系数据理论" class="headerlink" title="第六章 关系数据理论"></a>第六章 关系数据理论</h2><h3 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h3><ul>
<li>由于关系模型有严格的数学理论基础，并且可以向别的数据模式转换，因此，人们就以关系模型为背景来讨论这个问题，形成了数据库逻辑设计的一个有力工具——关系数据库的规范化理论。</li>
<li>作为一个二维表，关系要符合一个最基本的条件：每一个分量必须是不可分的数据项。满足了这个条件的关系模式就属于<strong>第一范式(1NF)。</strong></li>
<li>数据依赖是一个关系内部属性于属性之间的一种约束关系。这种约束关系是通过属性间值的相等与否体现出来的数据间相关关系。</li>
<li>人们已经提出了多种类型的数据依赖，其中最重要的是<strong>函数依赖和多值依赖。</strong></li>
<li>一个好的模式应当不会发生插入异常、删除异常和更新异常，数据冗余尽可能少。</li>
</ul>
<h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><ul>
<li><p>函数依赖</p>
<p>定义：设R(U)是属性集U上的关系模式，X,Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称X函数确定Y或Y函数依赖于X，记作X-&gt;Y.</p>
<p>函数依赖和别的数据依赖一样是语义范畴的概念，只能根据语义来确定一个函数依赖。</p>
<ul>
<li>X-&gt;Y,但Y不包含于X，则称X-&gt;Y是<strong>非平凡的函数依赖</strong></li>
<li>X-&gt;Y但Y包含于X，则称X-&gt;Y是平凡的函数依赖。对于任一关系模式，平凡函数依赖都是必然成立的，它不反应新的语义。若不特别声明，总是讨论非平凡的函数依赖。</li>
<li>若X-&gt;,则X称为这个函数依赖的决定属性组，也称为决定因素。</li>
<li>若X-&gt;Y,Y-&gt;X,则记作X<-->Y</--></li>
<li>若Y不函数依赖于X,则记作X!-&gt;Y</li>
<li>在R(U)中，如果X-&gt;Y，并且对于X的任何一个真子集X’，都有X’!-&gt;Y,则称Y对X<strong>完全函数依赖</strong>，记作X  F-&gt;Y</li>
<li>若X-&gt;,但Y不完全函数依赖于X，则称Y对X<strong>部分函数依赖</strong>，记作X P-&gt;Y</li>
<li>在R(U)中，如果X-&gt;Y(Y不包含于X),Y!-&gt;X,Y-&gt;Z,Z不包含于Y则称Z对X<strong>传递函数依赖</strong>。记作X 传递-&gt; Y</li>
</ul>
</li>
<li><p>码</p>
<ul>
<li>码是关系模式中的一个重要概念</li>
<li>设K为R&lt;U,F&gt;中的属性或属性组合，若K F-&gt;U,则K为R的<strong>候选码</strong>。</li>
<li>若候选码多于一个，则选定其中的一个为<strong>主码</strong></li>
<li>不包含在任何候选码中的属性称为<strong>非主属性或非码属性</strong>。最简单的情况，单个属性是码；最极端的情况，整个属性组是码，称为全码。</li>
<li>关系模式R中属性或属性组X并非R的码，但X是另一个关系模式的码，则称X是R的外部码，也称<strong>外码</strong>。</li>
</ul>
</li>
<li><p>范式</p>
<ul>
<li>关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。</li>
<li>一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化。</li>
</ul>
</li>
<li><p>2NF</p>
<ul>
<li><p>若R属于1NF，且每一个非主属性完全函数依赖于任何一个候选码，则R属于2NF。</p>
</li>
<li><p>一个关系模式R不属于2NF，就会产生以下几个问题：</p>
<ol>
<li>插入异常</li>
<li>删除异常</li>
<li>修改异常</li>
</ol>
</li>
</ul>
</li>
<li><p>3NF</p>
<ul>
<li>设关系模式R&lt;U,F&gt;属于1NF，若R中不存在这样的码X，属性组Y及非主属性Z使得X-&gt;Y,Y-&gt; 成立，Y!-&gt;,则称R&lt;U,F&gt;属于3NF</li>
<li>由定义可以证明，若R属于3NF,则每一个非主属性既不传递依赖于码，也不部分依赖于码。也就是说，可以证明如果R属于3NF，则必有R属于2NF</li>
</ul>
</li>
<li><p>BCNF</p>
<ul>
<li>关系模式R&lt;U,F&gt;属于1NF，若X-&gt;Y且Y不包含于X时X必含有码，则R&lt;U,F&gt;属于BCNF</li>
<li>也就是说，关系模式R&lt;U,F&gt;中，若每一个决定因素都包含码，则R&lt;U,F&gt;属于BCNF</li>
<li>由BCNF的定义可以得到结论，一个满足BCNF的关系模式由<ol>
<li>所有非主属性对每一个码都是完全函数依赖。</li>
<li>所有主属性对每一个不包含它的码也是完全函数依赖</li>
<li>没有任何属性完全函数依赖于非码的任何一组属性。</li>
</ol>
</li>
</ul>
</li>
<li><p>规范化小结</p>
<ul>
<li>规范化的基本思想是逐步消除数据依赖中不合适的部分，使模式中的各个关系模式达到某种程度的“分离”，即“一事一地”的模式设计原则。让一个关系描述一个概念，一个实体或者实体间的一种联系。若多于一个概念就把它“分离”出去。因此所谓规范化实质上是概念的单一化。</li>
<li><img src="/images/规范化过程.jpg" alt="规范化过程"></li>
<li>关系模式的规范化过程是通过对关系模式的分解来实现的，即把低一级的关系模式分解为若干个高以级的关系模式。</li>
</ul>
</li>
</ul>
<h3 id="数据依赖的公理系统"><a href="#数据依赖的公理系统" class="headerlink" title="数据依赖的公理系统"></a>数据依赖的公理系统</h3><p>下面首先讨论函数依赖的一个有效而完备的公理系统——Armstrong公理系统。</p>
<ul>
<li>定义：对于满足一组函数依赖F的关系模式R&lt;U,F&gt;,其任何一个关系r，若函数依赖X-&gt;Y都成立(即r中任意两元组t、s，若t[X]=s[X],则t[Y]=s[Y]),则称F逻辑蕴含X-&gt;Y.</li>
<li><p>Armstrong公理系统   设U为属性集总体，F是U上的一组函数依赖，于是有关系模式R&lt;U,F&gt;,对R&lt;U,F&gt;来说有以下的推理规则：</p>
<ul>
<li><p>A1自反律：若Y包含于X包含于U，则X-&gt;Y为所蕴含。</p>
</li>
<li><p>A2增广律：若X-&gt;Y为F所蕴含，且Z包含于U,则XZ-&gt;YZ为F所蕴含。</p>
</li>
<li><p>A3传递律：若X-&gt;Y及Y-&gt;Z为F所蕴含，则X-&gt;Z为F所蕴含</p>
<p><em>注意：由自反律所得到的函数依赖均是平凡的函数依赖，自反律的使用并不依赖于F。</em></p>
</li>
<li><p>定理 6.1：Armstrong推理规则是正确的。</p>
<ul>
<li>根据A1,A2,A3这三条推理规则可以得到下面三条很有用的推理规则<ol>
<li>合并规则：由X-&gt;Y,X-&gt;Z,有X-&gt;YZ</li>
<li>伪传递规则：X-&gt;Y,WY-&gt;Z,有XW-&gt;Z</li>
<li>分解规则：由X-&gt;Y及Z包含于Y，有X-&gt;Z</li>
</ol>
</li>
<li>定义6.12 在关系模式R&lt;U,F&gt;中为F所逻辑蕴含的函数依赖的全体叫作F的闭包，记为F+.</li>
<li>人们把自反律、传递律和增广律称为Armstrong公理系统。Armstrong公理系统是有效的、完备的。Armstrong公理的有效性指的是：由F出发根据Armstrong公理推导出来的每一个函数依赖一定在F+中；完备性指的是F+中的每一个函数依赖，必定可以由F出发根据Armstrong公理推导出来。</li>
</ul>
</li>
<li><p>定义6.13 设F为属性集U上的一组函数依赖，X、Y包含于U，XF+ = {A|X-&gt;A能由F根据Armstrong公理导出}，XF+称为属性集X关于函数依赖集F的闭包。</p>
</li>
<li><p>引理 6.2：设F为属性集U上的一组函数依赖，X,Y包含于U，X-&gt;Y能由F根据Armstrong公理导出的充分必要条件是Y包含于XF+。</p>
</li>
<li><p>定理6.2 Armstrong公理系统是有效的、完备的。</p>
</li>
<li><p>如果函数依赖集F满足下列条件，则称F为一个极小函数依赖集，亦称为最小依赖集或最小覆盖。</p>
<ol>
<li>F中任一函数依赖右部仅含有一个属性。</li>
<li>F中不存在这样的函数依赖X-&gt;A,使得F与F-{X-&gt;A}等价</li>
<li>F中不存在这样的函数依赖X-&gt;A,X有真子集Z使得F-{X-&gt;A}并{Z-&gt;A}与F等价。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="模式的分解"><a href="#模式的分解" class="headerlink" title="模式的分解"></a>模式的分解</h3><ul>
<li><p>模式分解的三个定义</p>
<ul>
<li><p>分解具有<strong>无损连接性</strong></p>
</li>
<li><p>分解要<strong>保持函数依赖</strong></p>
</li>
<li><p>分解既要保持函数依赖，又要无损连接性</p>
<p>这三个定义是实行分解的三条不同的准则。按照不同的分解准则，模式所能达到的分离程度各不相同，各种范式就是对分离程度的测度。</p>
</li>
</ul>
</li>
<li><p>模式分解的算法</p>
<ul>
<li>关于模式分解保持函数依赖，那么模式分离总可以达到3NF，但不一定能达到BCNF</li>
<li>若要求分解既保持函数依赖，又具有无损连接性，可以达到3NF，但不一定能达到BCNF</li>
<li>若要求分解具有无损连接性，那么一定可达到4NF</li>
<li>算法6.3(合成法)转换为3NF的保持函数依赖的分解(课本P198 6.4.3)</li>
<li>算法6.4 转换为3NF既有无损连接性又保持函数依赖的分解(课本P198 6.4.3)</li>
<li>算法6.5(分解法)转换为BCNF的无损连接分解 (课本P198 6.4.3)</li>
</ul>
</li>
</ul>
<h2 id="第七章-数据库设计"><a href="#第七章-数据库设计" class="headerlink" title="第七章 数据库设计"></a>第七章 数据库设计</h2><h3 id="数据库设计概述"><a href="#数据库设计概述" class="headerlink" title="数据库设计概述"></a>数据库设计概述</h3><p>未完待续。。。</p>
<p>—&gt;                    </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2020/04/06/杭电oj-1004/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/杭电oj-1004/" itemprop="url">杭电oj-1004</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T12:43:21+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/刷题/" itemprop="url" rel="index">
                    <span itemprop="name">刷题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="杭电oj-1004"><a href="#杭电oj-1004" class="headerlink" title="杭电oj-1004"></a>杭电oj-1004</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (a[i] &gt; max)</span><br><span class="line">	&#123;</span><br><span class="line">		max = a[i];</span><br><span class="line">		k = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen("C:/Users/19856/Desktop/wakaka.txt","r",stdin );</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">1005</span>][<span class="number">17</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> b[<span class="number">17</span>];</span><br><span class="line">	<span class="keyword">int</span> c[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">	<span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;b);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; (j &lt; n)&amp;&amp;(a[j][<span class="number">0</span>]!=<span class="string">'\0'</span>); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(a[j], b))c[j]++;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[i][<span class="number">0</span>] == <span class="string">'\0'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">strcpy</span>(a[i], b);</span><br><span class="line">			c[i]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	k = max(c, n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, a[k]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2020/04/06/blog写作之旅启程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/blog写作之旅启程/" itemprop="url">blog写作之旅启程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T12:06:27+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/汇编/" itemprop="url" rel="index">
                    <span itemprop="name">汇编</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="十分抱歉"><a href="#十分抱歉" class="headerlink" title="十分抱歉"></a>十分抱歉</h1><p>个人于19年搭建主页，由于学业繁忙，再没去触碰，近期将边学习边写blog，内容包括不局限于 计算机网络，汇编语言，Java学习，希望能强迫自己output，也希望自己能熟练掌握markdown写作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2020/04/06/hello-hexo-markdown/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/hello-hexo-markdown/" itemprop="url">hello hexo markdown</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T03:58:17+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2019/06/09/银河-夜/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/09/银河-夜/" itemprop="url">夜</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-09T01:27:12+08:00">
                2019-06-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/文学/" itemprop="url" rel="index">
                    <span itemprop="name">文学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>银河空旷、坦荡，列车奔驰在夜的星空，似乎没有方向，也无法预测终点将在何时何地到来。<br>生命，就像这遥远无依的茫然，充满了未知，有过光明与黑暗、挚爱与哀愁，然后脆弱得好似<br>掉进银河的一颗星，瞬间沉没于无垠的浩瀚。忧伤的少年啊，在人生虚妄而伤感的旅途中，就<br>这样缓慢悲伤地成长。也许你想要的，仅是些许的幸福和被这个世界所认同，却无奈地总被排<br>斥在外。但不要哭泣，你所搭乘的列车，终点不会是伤感的归宿，而是银河最深处幸福恬静的<br>天堂。<br>                                                                                 《银河铁道之夜》 — 〔日〕宫泽贤治</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2019/06/08/初到小白，请多关照/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/08/初到小白，请多关照/" itemprop="url">萌新Alice前来报道</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-08T00:00:00+08:00">
                2019-06-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/经验分享/" itemprop="url" rel="index">
                    <span itemprop="name">经验分享</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>第一次搭建blog，有点小激动(<em>≧︶≦))(￣▽￣</em> )ゞ<br>多多关照！</p>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1469289120&auto=1&height=66"></iframe>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>
