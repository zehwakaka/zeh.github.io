<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="版权所有  数据库第一章 绪论数据库系统概述 数据库四个基本概念：数据库系统(DBS)包括 数据库管理系统(DBMA)，数据库管理员(DBA)，数据库(DB)。 数据管理技术的产生和发展：数据管理技术经历了人工管理、文件管理、数据库系统三个阶段。      数据库系统的特点   数据结构化 共享性高、冗余度低且易扩充 数据独立性高：数据独立性、物理独立性、逻辑独立性 数据由数据库管理系统统一管理和">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库概论复习">
<meta property="og:url" content="http://zehwakaka.github.io/2020/08/22/数据库概论复习/index.html">
<meta property="og:site_name" content="Alice&#39;s blog">
<meta property="og:description" content="版权所有  数据库第一章 绪论数据库系统概述 数据库四个基本概念：数据库系统(DBS)包括 数据库管理系统(DBMA)，数据库管理员(DBA)，数据库(DB)。 数据管理技术的产生和发展：数据管理技术经历了人工管理、文件管理、数据库系统三个阶段。      数据库系统的特点   数据结构化 共享性高、冗余度低且易扩充 数据独立性高：数据独立性、物理独立性、逻辑独立性 数据由数据库管理系统统一管理和">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://zehwakaka.github.io/images/数据库系统的三级模式结构.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/参照关系.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/传统集合运算举例.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/连接.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/数据库对象命名机制的层次结构.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/数据类型1.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/数据类型2.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/相关子查询.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/any与all和聚集函数对应关系表.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/目标列表达式的可选格式.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/聚集函数的一般格式.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/where子句的条件表达式的可选格式.jpg">
<meta property="og:updated_time" content="2020-08-25T04:22:14.146Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据库概论复习">
<meta name="twitter:description" content="版权所有  数据库第一章 绪论数据库系统概述 数据库四个基本概念：数据库系统(DBS)包括 数据库管理系统(DBMA)，数据库管理员(DBA)，数据库(DB)。 数据管理技术的产生和发展：数据管理技术经历了人工管理、文件管理、数据库系统三个阶段。      数据库系统的特点   数据结构化 共享性高、冗余度低且易扩充 数据独立性高：数据独立性、物理独立性、逻辑独立性 数据由数据库管理系统统一管理和">
<meta name="twitter:image" content="http://zehwakaka.github.io/images/数据库系统的三级模式结构.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://zehwakaka.github.io/2020/08/22/数据库概论复习/">





  <title>数据库概论复习 | Alice's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Alice's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">郑</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2020/08/22/数据库概论复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">数据库概论复习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-22T15:10:42+08:00">
                2020-08-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><em>版权所有</em></p>
<hr>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h3><ul>
<li>数据库四个基本概念：数据库系统(DBS)包括 数据库管理系统(DBMA)，数据库管理员(DBA)，数据库(DB)。</li>
<li>数据管理技术的产生和发展：数据管理技术经历了人工管理、文件管理、数据库系统三个阶段。     </li>
<li>数据库系统的特点</li>
</ul>
<ol>
<li>数据结构化<ol start="2">
<li>共享性高、冗余度低且易扩充</li>
<li>数据独立性高：数据独立性、物理独立性、逻辑独立性</li>
<li>数据由数据库管理系统统一管理和控制</li>
</ol>
</li>
</ol>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><ul>
<li><p>据模型也是一种模型，它是对现实世界数据特征的抽象。数据模型是数据库系统的核心和基础。</p>
</li>
<li><p>两类数据模型：第一类是概念模型，第二类是逻辑模型和物理模型。 首先将现实世界抽象为信息世界，然后将信息世界转换为机器世界。</p>
</li>
<li><p>概念模型：概念模型最常用的方法是实体-联系方法，E-R方法也称为E-R模型</p>
<ol>
<li>实体：客观存在并可互相区别的事物称为实体。</li>
<li>属性：实体所具有的某一特性称为属性。</li>
<li>码：唯一标识实体的属性集称为码。</li>
<li>实体型：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。</li>
<li>实体集：同一类型实体的集合称为实体集</li>
<li>联系：实体之间的联系通常是指不同实体集之间的联系。实体之间的联系有一对一、一对多和多对多等多种类型。<br>数据模型的组成要素</li>
</ol>
</li>
<li><p>数据结构：数据结构描述数据库的组成对象以及对象之间的联系。</p>
</li>
<li><p>数据操作：数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。</p>
</li>
<li><p>数据的完整性约束条件：数据的完整性约束条件是一组完整性规则。</p>
</li>
<li><p>常用的数据模型</p>
<ol>
<li><p>层次模型</p>
</li>
<li><p>网状模型</p>
</li>
<li><p><strong>关系模型</strong></p>
<ol>
<li><p>关系模型的数据结构</p>
<ul>
<li><p>关系：一个关系对应通常说的一张表</p>
</li>
<li><p>元组：表中的一行即为一个元组</p>
</li>
<li><p>属性：表中的一列即为一个属性，给每一个属性起一个名称即属性名</p>
</li>
<li><p>码：也称码键。表中的某个属性组，它可以唯一确定一个元组</p>
</li>
<li><p>域：域是一组具有相同数据类型的值的集合</p>
</li>
<li><p>分量：元组中的一个属性值</p>
<p><em>关系模型要求关系必须是规范的，关系的每一个分量必须是一个不可分的数据项</em></p>
</li>
</ul>
</li>
<li><p>关系模型的数据操纵与完整性约束</p>
<p><em>关系模型中的数据操作是集合操作，操作对象和操作结果都是关系。关系模型把存取路径向用户隐蔽起来</em></p>
</li>
<li><p>关系模型的优缺点</p>
<ul>
<li>关系模型与格式化模型不同，他是建立在严格的数学基础上的。</li>
<li>关系模型的概念单一</li>
<li>关系模型的存取路径对用户透明</li>
</ul>
</li>
</ol>
</li>
<li><p>面向对象数据模型</p>
</li>
<li><p>对象关系数据模型</p>
</li>
<li><p>半结构化数据模型</p>
</li>
</ol>
</li>
</ul>
<h3 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h3><ul>
<li><p>数据库系统模式的概念：在数据模型中有“型”和“值”的概念。型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值。</p>
<p><em>模式是相对稳定的，而实例是相对变动的。</em></p>
</li>
<li><p><strong>数据库系统的三级模式结构图：</strong></p>
</li>
<li><p><img src="/images/数据库系统的三级模式结构.jpg" alt="数据库系统的三级模式结构" style="zoom:25%;transform:rotate(-90deg);">    </p>
</li>
<li><p><strong>三级模式</strong></p>
<ol>
<li><p>模式：模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p>
</li>
<li><p>外模式：外模式也称子模式或用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</p>
</li>
<li><p>内模式：内模式也称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。</p>
</li>
</ol>
</li>
<li><p><strong>数据库的二级映像功能与数据独立性</strong></p>
<ol>
<li><p>外模式/模式映像：当模式改变时(例如增加新的关系、新的属性、改变属性的数据类型等)，由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，<strong>保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。</strong></p>
</li>
<li><p>模式/内模式映像：当数据库的存储结构改变时(例如选用了另一种存储结构)，由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变。<strong>保证了数据与程序的物理独立性，简称数据的物理独立性。</strong></p>
<p><em>数据与程序之间的独立性使得数据的定义和描述可以从应用程序中分离出去。另外，由于数据的存取由数据库管理系统管理，从而简化了应用程序的编制，大大减少了应用程序的维护和修改。</em></p>
</li>
</ol>
</li>
<li><p>据库系统的组成</p>
<ul>
<li><p>包括硬件平台及数据库、软件、人员。</p>
</li>
<li><p>数据库管理员(DBA)职责：</p>
<ul>
<li>决定数据库中的信息内容和结构</li>
<li>决定数据库的存储结构和存储策略</li>
<li>定义数据的安全性要求和完整性约束条件</li>
<li>监控数据库的使用和运行</li>
<li>数据库的改进和重组、重构</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章 关系数据库"></a>第二章 关系数据库</h2><h3 id="关系数据结构及形式化定义"><a href="#关系数据结构及形式化定义" class="headerlink" title="关系数据结构及形式化定义"></a>关系数据结构及形式化定义</h3><ul>
<li><p>关系</p>
<ol>
<li><p>域：域是一组具有相同数据类型的值的集合。</p>
</li>
<li><p><strong>笛卡尔积</strong>：笛卡尔积定义，给定一组域D1,D2,…,Dn，允许其中某些域是相同的，D1,D2,…,Dn的笛卡尔积为</p>
<p>​                                                        <em>D1\</em>D2*…*Dn = {(d1,d2,…,dn)|di属于Di,i=1,2,…,n}*<br>​                           其中，每一个元素(d1,d2,…,dn)叫作一个n元组，或简称元组。元素中的每一个值di叫作一个分量。<br>​                           一个域允许的不同取值个数称为这个域的基数。</p>
</li>
<li><p><strong>关系：</strong>定义，D1*D2*…*Dn的子集叫做在域D1,D2,…,Dn上的关系，表示为R(D1,D2,…,Dn)这里R表示关系的名字,n是关系的<strong>目或度</strong>。当n = 1时，称该关系为一元关系。当n = 2时，称该关系为二元关系。</p>
<ul>
<li><p>某一属性组的值能唯一的标识一个元组，而其子集不能，则称该属性组为<strong>候选码</strong>。若一个关系有多个候选码，则选定其中一个为<strong>主码</strong>。候选码的诸属性称为<strong>主属性</strong>。不包含在任何候选码中的属性称为<strong>非主属性或非码属性</strong>。在最简单的情况下，候选码只包含一个属性。在最极端的情况下，关系模式的所有属性是这个关系模式的候选码，称为<strong>全码</strong>。</p>
</li>
<li><p>关系可以有三种类型：基本关系(通常又称为基本表或基表)、查询表和视图表。</p>
</li>
<li><p>关系的性质：</p>
<ol>
<li><p>列是同质的，即每一列中的分量是同一类型的数据，来自同一个域。</p>
</li>
<li><p>不同的列可出自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。</p>
</li>
<li><p>列的顺序无所谓，即列的次序可以任意交换。</p>
</li>
<li><p>任意两个元组的候选码不能取相同的值。</p>
</li>
<li><p>行的顺序无所谓，即行的次序可以任意交换。</p>
</li>
<li><p>分量必须取原子值，即每一个分量都必须是不可分的数据项</p>
<p><strong>这些规范条件中最基本的一条就是，关系的每一个分量必须是一个不可分的数据项。规范化的关系简称为范式(NF)。</strong></p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>关系模式</p>
<ul>
<li>关系的描述称为关系模式。它可以形式化的表示为R(U,D,DOM,F)。其中R为关系名，U为组成改关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合。</li>
</ul>
</li>
<li><p>关系数据库</p>
<ul>
<li>关系数据库也有型和值之分。关系数据库的型也称为关系数据库模式，是对关系数据库的描述。关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。</li>
</ul>
</li>
</ul>
<h3 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h3><ul>
<li><p>基本的关系操作：关系模型中常用的关系操作包括<strong>查询操作</strong>和<strong>插入、删除、修改操作</strong>两大部分。</p>
<ul>
<li><p>关系的查询表达能力很强，是关系操作中最主要的部分。查询操作又可以分为旋转、投影、连接、除、并、差、交、笛卡尔积等。其中<strong>选择、投影、并、差、笛卡尔积是5种基本操作</strong>。</p>
</li>
<li><p>关系操作的特点是集合操作方式，即操作的对象和结果都是集合。这种操作方式也称为一次一集合的方式。相应的非关系数据模型的数据操作方式则为一次一记录的方式。</p>
</li>
</ul>
</li>
<li><p>关系数据语言的分类</p>
<ul>
<li><p>早期的关系操作能力通常用代数方式或逻辑方式来表示，分别称为<strong>关系代数和关系演算</strong>。关系代数用对关系的运算来表达查询要求，关系演算则用谓词来表达查询要求。关系演算又可按谓词变元的基本对象是元组变量还是域变量分为<strong>元组关系演算和域关系演算</strong>。</p>
</li>
<li><p>还有一种介于关系代数和关系演算之间的<strong>结构化查询语言(SQL)</strong>。SQL是<strong>集查询、数据定义语言、数据操纵语言和数据控制语言于一体的关系数据语言。</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h3><ul>
<li><p>关系模型中有三类完整性约束：<strong>实体完整性、参照完整性和用户定义的完整性。</strong>其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作<strong>关系的两个不变性。</strong></p>
<ol>
<li><p>实体完整性：实体完整性规则，若属性(指一个或一组属性)A是基本关系R的主属性，则A不能取空值。所谓空值就是“不知道”或“不存在”或“无意义”的值。</p>
<p><em>对实体完整性规则说明：</em></p>
<ul>
<li><p>实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。</p>
</li>
<li><p>现实世界中的实体是可区分的，即它们具有某种唯一性标识。例如每个学生都是独立的个体，是不一样的。</p>
</li>
<li><p>相应的，关系模型中以主码作为唯一性标识。</p>
</li>
<li><p>主码中的属性不能取空值。</p>
</li>
</ul>
</li>
<li><p>参照完整性：<strong>设F是基本关系R的一个或一组属性，但不是关系R的码，Ks是基本关系S的码。如果F与Ks相对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。</strong></p>
<p><img src="/images/参照关系.jpg" alt="参照关系与被参照关系"></p>
<ul>
<li><p>参照完整性规则：若属性(或属性组)F是基本关系R的外码，它与基本关系S的主码Ks相对应(基本关系R和S不一定是不同的关系)，则对于R中每个元组在F上的值必须：</p>
<ol>
<li><p>或者取空值(F的每个属性值均为空值)</p>
</li>
<li><p>或者等于S中某个元组的主码值。</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>用户定义的完整性</p>
<p><em>用户定义的完整性就是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。</em></p>
</li>
</ol>
</li>
</ul>
<h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p>  关系代数是一种抽象的查询语言，它用对关系的运算来表达查询。</p>
<p>  任何一种运算都是将一定的运算符作用于一定的运算对象上，得到预期的运算结果。所以运算对象、运算符、运算结果是运算的三大要素。</p>
<p>  关系代数用到的运算符包括两类：集合运算符和专门的关系运算符</p>
<p>  关系代数的运算按运算符的不同可分为传统的集合运算和专门的关系运算两类。</p>
<ul>
<li><p>传统的集合运算</p>
<p><strong>传统的集合运算是二目运算，包括并、差、交、笛卡尔积四种运算</strong></p>
<p>定义如下：</p>
<ol>
<li><p>并：R∪S ={t|t属于R V t属于S}    其结果仍为n目关系，由属于R或属于S的元组组成。</p>
</li>
<li><p>差：R-S = {t|t属于R ∧ t不属于S}  其即结果关系仍为n目关系，由属于R而不属于S的所有元组组成。</p>
</li>
<li><p>交：R∩S = {t|t属于R ∧ t属于S}    其结果关系仍为n目关系，由既属于R又属于S的元组组成。关系的交可以用差来表示，即</p>
<p>R∩S = R - (R - S)</p>
</li>
<li><p>笛卡尔积：R*S = {tr 连ts|tr属于R ∧ ts属于S}</p>
<p><img src="\images\传统集合运算举例.jpg" alt="传统集合运算举例"></p>
</li>
</ol>
</li>
<li><p>专门的关系运算</p>
<p><strong>专门的关系运算包括选择、投影、连接、除运算</strong></p>
<p> 记号：</p>
<ol>
<li><p>设关系模式为R(A1,A2,…,An)，它的一个关系设为R。t属于R表示t是R的一个元组。t[Ai]则表示元组t中相应于属性Ai的一个分量。</p>
</li>
<li><p>若A = {Ai1,Ai2,…,Aik}，其中Ai1，Ai2，…，Aik是A1，A2，…，An中的一部分，则A称为属性列或属性组。t[A] = (t[Ai1],t[Ai2],…,t[Aik])表示元组t在属性列A上诸分量的集合，A反则表示{A1,A2,…,An}中去掉{Ai1,Ai2,…,Aik}后剩余的属性组。</p>
</li>
<li><p>R为n目关系，S为m目关系。tr属于R，ts属于S，tr连接ts称为元组的连接或元组的串接。他是一个n+m列的元组前n个分量为R中的一个n元组，后m个分量为S中的一个m元组。</p>
</li>
<li><p>给定一个关系R(X,Z),X和Z为属性组。当t[X] = x时，x在R<strong>象集</strong>定义为</p>
<p>​    Zx = {t[Z]|t属于R，t[X] = x}</p>
<p>它表示R中属性组X上值为x的诸元组在Z上分量的集合。</p>
</li>
</ol>
<ul>
<li><p>选择：选择又称为限制。它是在关系R中选择满足给定条件的诸元组，记作   的塔F(R) = {t|t属于R ∧ F(t)= ‘真’}</p>
</li>
<li><p>投影：关系R上的投影是从R中选择出若干属性列组成新的关系。记作   pi A(R) = {t[A]|t属于R} 其中A为R中的属性列。投影是从列的角度进行的运算。</p>
</li>
<li><p>连接：连接也称为 θ连接。他是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。记作：</p>
<p> <img src="/images/连接.jpg" alt="连接"> </p>
<ul>
<li><p>连接运算中有两种最为重要也最为常用的连接，一种是等值连接，另一种是自然连接。θ为“=”的连接运算称为<strong>等值连接</strong>是从关系R与S的广义笛卡尔积中选取A、B属性值相等的那些元组。<strong>自然连接</strong>是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉。即若R和S中具有相同的属性组B,U为R和S的全体属性集合。一般的连接操作是从行的角度进行运算，但自然连接还需要取消重复列，所以是<strong>同时从行和列的角度进行运算</strong>。</p>
</li>
<li><p>两个关系R和S在做自然连接时，选择两个关系在公共属性上值相等的元组构成新的关系。此时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃，同样，S中某些元组也可能被舍弃。<strong>这些被舍弃的元组称为悬浮元组</strong>。</p>
</li>
<li><p>如果把悬浮元组也保存在结果关系中，而在其他属性上填空值(NULL)，那么这种连接就叫做外连接，记作R =&gt;&lt;= S;如果只保留左边关系R中的悬浮元组就叫做左外连接R=&gt;&lt;S;如果只保留右边关系S中的悬浮元组就叫做右外连接，记作R&gt;&lt;=S</p>
</li>
</ul>
</li>
<li><p>除运算：设关系R除以关系S的结果为关系T，则<strong>T包含所有在R但不在S中的属性及其值，且T的元组与S的元组的所有组合都在R中。</strong></p>
<ul>
<li>下面用象集来定义除法：给定关系R(X,Y)和S(Y,Z)，其中X,Y,Z为属性组。R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集。</li>
<li>R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在X属性列上的投影：元组在X上分量值x的象集Yx包含S在Y上投影的集合。记作：R/S = {Tr[X]|tr属于R ∧ piY(S)包含于Yx} 其中Yx为x在R中的象集，x = tr[X]。除操作是同时从行和列角度进行运算。</li>
<li>R/S -&gt;投影-&gt;象集-&gt;包含</li>
</ul>
</li>
</ul>
</li>
<li><p>其中并，差，笛卡尔积，选择和投影这五种运算为基本的运算。其他三种运算，即交，连接和除，均可以用这5种基本运算来表达。引进他们并不增加语言的能力，但可以简化表达</p>
</li>
<li><p>关系代数中，这些运算经有限次复合后形成的表达式称为关系代数表达式。</p>
</li>
</ul>
<hr>
<h2 id="第三章-关系数据库标准语言SQL"><a href="#第三章-关系数据库标准语言SQL" class="headerlink" title="第三章 关系数据库标准语言SQL"></a>第三章 关系数据库标准语言SQL</h2><h3 id="SQL-概述"><a href="#SQL-概述" class="headerlink" title="SQL 概述"></a>SQL 概述</h3><ul>
<li><p>SQL 的产生与发展</p>
<p>目前，没有一个数据库系统能够支持SQL标准的所有概念和特性。大部分数据库系统能支持SQL/92标准中的大部分功能以及SQL99、SQL2003中的部分新概念。同时，许多软件厂商对SQL基本命令集还进行了不同程度的扩展和修改，又可以支持标准以外的一些功能特性。</p>
</li>
<li><p>SQL的特点</p>
<ol>
<li><p>综合统一</p>
</li>
<li><p>高度非过程化</p>
<p>只要提出“做什么”，而无须指明“怎么做”，因此无须了解存取路径。存取路径的选择以及SQL的操作过程由系统自动完成。</p>
</li>
<li><p>面向集合的操作方式</p>
</li>
<li>以同一种语法结构提供多种使用方式</li>
<li>语言简洁，易学易用 </li>
</ol>
</li>
</ul>
<h3 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h3><p><em>一个关系数据库管理系统的实例中可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象。</em></p>
<p><img src="/images/数据库对象命名机制的层次结构.jpg" alt="数据库对象命名机制的层次结构"></p>
<ul>
<li><p>模式的定义与删除</p>
<ul>
<li><p>定义模式：在SQL中，模式定义语句如下：create schema &lt;模式名&gt; authorization &lt;用户名&gt; </p>
<p>​                                                     <em>如果没有指定&lt;模式名&gt;，那么&lt;模式名&gt;隐含为&lt;用户名&gt;</em></p>
<p><em>要创建模式，调用该命令的用户必须拥有数据库管理员权限，或者获得了数据库管理员授予的create schema 的权限</em></p>
</li>
<li><p>目前，create chema 中可以接受 create table，create view和grant 子句。也就是说用户可以在创建模式的同时在这个模式定义中进一步创建基本表、视图。定义授权。即：create schema &lt;模式名&gt; authorization &lt;用户名&gt; [&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]</p>
</li>
<li><p>删除模式：在SQL中，删除模式语句如下，drop schema &lt;模式名&gt;&lt;cascade|restrict&gt; </p>
<p><em>其中cascade和restrict两者必选其一。选择了cascade(级联)，表示在删除模式的同时把该模式中所有的数据库对象全部删除；选择了restrict(限制)，表示如果该模式中已经定义了下属的数据库对象(如表，视图等)，则拒绝该删除语句的执行。只有当该模式中没有任何下属的对象时才能执行 drop schema语句。</em></p>
</li>
</ul>
</li>
<li><p>基本表的定义、删除与修改</p>
<ul>
<li><p>定义基本表：创建了一个模式就建立了一个数据库的命名空间，一个框架。在这个空间中首先要定义的是该模式包含的数据库基本表。SQL语言使用create table 语句定义基本表，其基本格式如下：</p>
<p><em>create table &lt;表名&gt;(&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件][,&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件]][,表级完整性约束条件])</em></p>
<p><em>参照表和被参照表可以是同一个表</em></p>
</li>
<li><p>数据类型：</p>
<p><img src="\images\数据类型1.jpg" alt="数据类型1"><br><img src="\images\数据类型2.jpg" alt="数据类型1"></p>
</li>
<li><p>模式与表</p>
<p>每一给基本表都属于某一个模式，一个模式包含多个基本表。当定义基本表时一般可以有三种方法定义它所属的模式，现在要在S-T中定义Student、Course、SC等基本表。</p>
<ol>
<li><p>方法一：在表名中明显的给出模式名。 create table ”S-T“.Student(…);<em>Student所属的模式是S-T</em></p>
</li>
<li><p>方法二：在创建模式语句中同时创建表</p>
</li>
<li><p>方法三：设置所属的模式，这样在创建表时表名中不必给出模式名。</p>
<p>当用户创建基本表(其他数据库对象也一样)时若没有指定模式，系统根据搜索路径来确定该对象所属的模式。</p>
<p>搜索路径包含一组模式列表，关系数据库管理系统会使用模式列表中第一个存在的模式作为数据库对象的模式名。若搜索路径中的模式名都不存在，系统将给出错误。</p>
<p><em>使用下面的语句可以显示当前的搜索路径： show search_path</em></p>
<p><em>搜索路径当前默认值是$user，PUBLIC。其含义是首先搜索与用户名相同的模式名，如果该模式名不存在，则使用PUBLIC模式</em></p>
<p><em>数据库管理员也可以设置搜索路径，如：SET search_path TO “S-T”,PUBLIC; 然后，定义基本表。实际结果是建立了S-T.Student基本表。因为关系数据库管理系统发现路径中第一个模式名S-T存在，就把该模式作为基本表Studnt所属的模式。</em></p>
</li>
</ol>
</li>
<li><p>修改基本表</p>
<p>SQL语言用alter table语句修改基本表，其一般格式为</p>
<p>alter table &lt;表名&gt;</p>
<p>[add [column] &lt;新列名&gt;&lt;数据类型&gt;[完整性约束]]</p>
<p>[add &lt;表级完整性约束&gt;]</p>
<p>[drop [column] &lt;列名&gt;[cascade|restrict]]</p>
<p>[drop constraint &lt;完整性约束名&gt; [restrict|cascade]]</p>
<p>[alter column &lt;列名&gt;&lt;数据类型&gt;]</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>删除基本表</p>
<p>drop table &lt;表名&gt;[restrict|cascade]</p>
<p>若选择restrict，则该表的删除是有限制条件的。欲删除的基本表不能被其他表的约束所引用(如cheack，foreign key等约束)，不能有视图，不能有触发器，不能有存储过程或函数等。如果存在这些依赖该表的对象，则此表不能被删除。</p>
<p>若选择cascade，则该表的删除没有限制条件。在删除基本表的同时，相关的依赖对象，例如视图，都将被一起删除。</p>
<p><em>默认情况是restrict</em></p>
</li>
<li><p>索引的建立与删除</p>
<p>数据库索引有多种类型，常见索引包括顺序文件上的索引、B+树索引、散列索引、位图索引等。<strong>顺序文件上的索引</strong>是针对按指定属性值升序或降序存储的关系，在该属性上建立一个顺序索引文件，索引文件由属性值和相应的元组指针组成。<strong>B+树索引</strong>是将索引属性组织成B+树形式，B+树的叶结点为属性值和相应的元组指针。B+树索引具有动态平衡的优点。<strong>散列索引</strong>是建立若干个桶，将索引属性按照其散列函数值映射到相应桶中，桶中存放索引属性值和相应的元组指针。散列索引具有查找速度快的特点。<strong>位图索引</strong>是用位向量记录所有属性中可能出现的值，每个位向量对于一个可能值。</p>
<p><em>关系数据库管理系统在执行查询时会自动选择合适的索引作为存取路径，用户不必也不能显式的选择索引。</em></p>
<ol>
<li><p>建立索引：在SQL语言中，建立索引使用 create index 语句，一般格式为</p>
<p>create [unique][cluster] index &lt;索引名&gt;</p>
<p>on &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;]]…)</p>
<p>其中，&lt;表名&gt;是要建索引的基本表的名字。索引可以建立在该表的一列或多列上，各列名之间用逗号分隔。每个&lt;列名&gt;后面还可以用&lt;次序&gt;指定索引值的排列次序，可选ASC(升序)或DESC(降序)，默认值为ASC.</p>
<p>UNIQUE表明此索引每一个索引值只对应唯一的数据记录。</p>
<p>CLUSTER 表示要建立的索引是聚簇索引。</p>
</li>
<li><p>修改索引</p>
<p>对于已经建立的索引，如果需要对其重新命名，可以使用ALTER INDEX 语句。其一般格式为：</p>
<p>ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;</p>
</li>
<li><p>删除索引</p>
<p>在SQL中，删除索引使用DROP INDEX语句，其一般格式为</p>
<p>DROP INDEX &lt;索引名&gt;</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>数据字典</p>
<p>数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有的定义信息，包括关系模式定义，视图定义，索引定义，完整性约束定义，各类用户对数据库的操作权限，统计信息等。</p>
</li>
</ul>
<h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><ul>
<li><p>数据查询是数据库的核心操作。SQL提供了SELECT语句进行数据查询，该语句具有灵活的使用方式和丰富的功能。其一般格式为</p>
<p>select [all|distinct] &lt;目标列表达式&gt;[,&lt;目标列表达式&gt;]…</p>
<p>from &lt;表名或视图名&gt; [,&lt;表名或视图名&gt;…]|(&lt;select语句&gt;)[AS]&lt;别名&gt;</p>
<p>[where&lt;条件表达式&gt;]</p>
<p>[group by &lt;列名1&gt;[having&lt;条件表达式&gt;]]</p>
<p>[order by&lt;列名2&gt;[asc|desc]]</p>
<p>整个select语句的含义是，根据where子句的条件表达式从from子句指定的基本表、视图或派生表中找出满足条件的元组，再按select子句中的目标列表达式选出元组中的属性值形成结果表。</p>
<p>如果由group by 子句，则将结果按&lt;列名1&gt;的值进行分组，该属性列值相等的元组为一组。通常会在每组中作用聚集函数。如果 group by子句带having短语，则只有满足指定条件的组才予以输出。</p>
<p>如果有order by子句，则结果表还有按&lt;列名2&gt;的值升序或降序排序。</p>
<p>select语句既可以完成简单的单表查询，也可以完成复杂的连接查询和嵌套查询。</p>
</li>
<li><p>单表查询</p>
<ol>
<li><p>选择表中的若干列</p>
<ul>
<li><p>查询指定列：如select Sno，Sname from Student。各个列的顺序可以与表中的顺序不一致</p>
</li>
<li><p>查询全部列：如select * from Student</p>
</li>
<li><p>查询经过计算的值：select 子句的&lt;目标列表达式&gt;不仅可以使表中的属性列，也可以是表达式。如：select Sname，‘Year of Birth：’，2014-Sage BIRTHDAY from Student</p>
</li>
</ul>
</li>
<li><p>选择表中的若干元组</p>
<ul>
<li><p>消除取值重复的行</p>
<p>两个本科并不完全相同的元组在投影到指定的某些列上后，可能会变成相同的行。可以使用distinct消除他们。</p>
<p>如：select distinct Sno from SC</p>
</li>
<li><p>查询满足条件的元组</p>
<p>查询满足条件的元组可以通过where子句实现。where子句常用的查询条件</p>
<ol>
<li><p>比较大小</p>
</li>
<li><p>确定范围：谓词between…and…和not between…and…可以用来查找属性值在(或不在)指定范围内的元组，其中<strong>between后是范围的下限(即低值)，and后是范围的上限(即高值)。</strong></p>
</li>
<li><p>字符匹配</p>
<p>谓词like可以用来进行字符串的匹配。其一般语法格式如下：</p>
<p>[not] like ‘&lt;匹配串&gt;’ [escape’&lt;换码字符&gt;’]</p>
<p>其含义是查找指定的属性列值与&lt;匹配串&gt;相匹配的元组。&lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符%和_。其中：</p>
<p>%(百分号)代表任意长度(长度可以为0)的字符串。例如a%b表示以a开头，以b结尾的任意长度的字符串。</p>
<p>_(下横线)代表任意单个字符</p>
<p><strong>如果用户要查询的字符串本身就含有通配符%或_,这是就要使用escape ‘&lt;换码字符&gt;’ 短语对通配符进行转义了。</strong></p>
</li>
<li><p>涉及空值的查询</p>
<p>IS和NOT IS</p>
</li>
<li><p>多重条件查询</p>
<p>AND 和 OR</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>order by子句</p>
<p>用户可以用order by子句对查询结果按照一个或多个属性列的升序(asc)或降序(desc)排列，默认值为升序。</p>
<p>对于空值，排序时显示的次序由具体系统实现来决定。例如按升序排，含空值的元组最后显示；按降序排，空值的元组则最先显示。各个系统的实现可以不同，只要保持一致就行。</p>
</li>
<li><p>聚集函数</p>
<p>为了进一步方便用户，增强检索功能，SQL提供了许多聚集函，主要有：</p>
</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">聚集函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">count(*)</td>
<td>统计元组个数</td>
</tr>
<tr>
<td style="text-align:center">count([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>统计一列中值的个数</td>
</tr>
<tr>
<td style="text-align:center">sum([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>计算一列值的总和(此列必须是数值型)</td>
</tr>
<tr>
<td style="text-align:center">sum([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>计算一列值的平均值(此列必须是数值型)</td>
</tr>
<tr>
<td style="text-align:center">max([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>求一列值中的最大值</td>
</tr>
<tr>
<td style="text-align:center">min([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>求一列值中的最小值</td>
</tr>
</tbody>
</table>
<p>   如果指定distinct短语，则表示在计算时要取消指定列中的重复值。如果不指定distinct短语或指定all短语(all为默认值)，则表示不取消重复值。</p>
<p>  <strong>当聚集函数遇到空值时，除count(*)外，都跳过空值而只处理非空值。聚集函数只能用于select子句和group by中的having子句。</strong></p>
<ol start="5">
<li><p>group by子句</p>
<p>group by子句将查询结果按某一列或多列的值分组，值相等的为一组。</p>
<p>对查询结果分组的目的是为了细化聚集函数的作用对象。如果未对查询结果分组，聚集函数将作用于整个查询结果。分组后聚集函数将作用于每一个组，即每一组都有一个函数值。</p>
<p>例子：见课本P99 例3.48</p>
</li>
</ol>
<ul>
<li><p>连接查询</p>
<p>若一个查询同时涉及两个以上的表，则称之为连接查询。连接查询是关系数据库中最主要的查询，包括等值连接查询、自然连接查询、非等值连接查询、自身连接查询、外连接查询和复合条件连接查询等。</p>
<ol>
<li><p>等值与非等值连接查询</p>
<ul>
<li><p>连接查询的where子句中用来连接两个表的条件称为<strong>连接条件或连接谓词</strong>其一般格式为</p>
<p>[&lt;表名1&gt;.]&lt;列名1&gt;&lt;比较运算符&gt;[&lt;表名2&gt;.]&lt;列名2&gt;</p>
<p>此外连接谓词还可以使用下面形式：</p>
<p>[&lt;表名1&gt;.]&lt;列名1&gt; between [&lt;表名2&gt;.]&lt;列名2&gt; and [&lt;表名3&gt;.]&lt;列名3&gt;</p>
<p><strong>当连接运算符为=时，称为等值连接。使用其他运算符称为非等值连接。</strong></p>
<p>连接谓词中的列名称为连接字段。连接条件中的各连接字段类型必须是可比的，但名字不必相同。</p>
</li>
<li><p>关系数据库管理系统执行该连接操作的一种可能过程是：首先在表Student中找到第一个元组，然后从头开始扫描SC表，逐一查找与Student第一个元组的Sno相等的SC元组，找到后就将Student中的第一个元组与该元组拼接起来，形成结果表中的一个元组。SC全部查找完后，再找Student中第二个元组，然后再从头开始扫描SC，逐一查找满足连接条件的元组，找到后就将Student中的第二个元组与该元组拼接起来，形成结果表中一个元组。重复以上操作。<strong>这就是嵌套循环连接算法的基本思想。</strong></p>
</li>
<li><p>如果在SC表Sno上建立了索引的化，就不用每次全表扫描SC表了，而是根据Sno值通过索引找到相应的SC元组。用索引查询SC中满足条件的元组一般会比全表扫描快。若在等值连接中<strong>把目标列中重复的属性列去掉则为自然连接。</strong></p>
</li>
<li><p>一条SQL语句可以同时完成选择和连接查询，这时where子句是由连接谓词和选择谓词组成的复合条件。</p>
</li>
</ul>
</li>
<li><p>自身连接</p>
<p>连接操作不仅可以在两个表之间进行，也可以是一个表与其自己进行连接，称为表的<strong>自身连接。</strong>例：select FIRST.Cno，SECOND.Cpno</p>
<p>​                from Course FIRST,Course SECOND</p>
<p>​                where FIRST.Cpno = SECOND.Cno</p>
</li>
<li><p>外连接</p>
<p>若某个学生没有选课，<strong>仍把Student的悬浮元组保存在结果关系中</strong>，而在SC表的属性上填空值NULL，这时就需要使用外连接。</p>
<p><strong>左外连接</strong>列出左边关系中所有的元组，<strong>右外连接</strong>列出右边关系中所有的元组。</p>
</li>
<li><p>多表连接</p>
<p>连接操作处理可以是<strong>两表连接</strong>、一个表与其自身连接外，还可以是两个以上的表进行连接，猴子通常称为<strong>多表连接</strong>。</p>
</li>
</ol>
</li>
<li><p>嵌套查询</p>
<p>在SQL语言中，<strong>一个select-from-where语句称为一个查询块</strong>。将一个查询块嵌套在另一个查询块的where子句或having短语的条件中的查询称为嵌套查询。上层的查询块称为外层查询或父查询，下层查询块称为内层查询或子查询。</p>
<p>SQL语言允许多层嵌套查询，即一个子查询中还可以嵌套其他子查询。需要特别指出的是，<strong>子查询的select语句中不能使用order by子句</strong>，order by子句只能对最终查询结果排序。</p>
<p>嵌套查询使用户可以用多个简单查询构成复杂的查询，从而增强SQL的查询能力。以层层嵌套的方式来构造程序正是SQL中”结构化“的含义所在。</p>
<ol>
<li><p>带有in谓词的子查询</p>
<p>子查询的查询条件不依赖于父查询，称为<strong>不相关子查询</strong></p>
<p>实现同一个查询请求可以有多种方法，当然不同的方法其执行效率可能会有差别，甚至会差别很大。这就是数据库编程人员应该掌握的数据库性能调优技术。</p>
<p>有些嵌套查询可以用连接运算代替，有些是不能替代的。</p>
<p>查询的查询条件不依赖于父查询，这类子查询称为不相关子查询。不相关子查询是较简单的一类子查询。<strong>如果子查询的查询条件依赖于父查询，这类子查询称为相关子查询，整个查询语句称为相关嵌套查询语句。</strong></p>
</li>
<li><p>带有比较运算符的子查询</p>
<p><img src="\images\相关子查询.jpg" alt="相关子查询"></p>
<p>x是表SC的别名，又称为元组变量，可以用来表示SC的元组。内层查询是求一个学生所有选修课程平均成绩的，至于是哪个学生的平均成绩要看<strong>参数x.Sno的值，而该值是与父查询相关的，因此这类查询称为相关子查询。</strong></p>
<p><strong>求解相关子查询不能像求解不相关子查询那样一次将子查询求解出来，然后求解父查询。</strong>内层查询由于与外层查询有关，因此必须反复求值。</p>
</li>
<li><p>带有any(some) 或 all 谓词的子查询</p>
<p>子查询返回单值时可以用比较运算符，但返回多值时要用any(有的系统用some)或all谓词修饰符。而使用any或all谓词时则必须同时使用比较运算符。</p>
<ul>
<li><em>&gt;any  大于子查询结果中的某个值</em></li>
<li><em>&gt;all  大于子查询结果中的所有值</em></li>
</ul>
<p>例子见课本P107 例3.58</p>
<p>例子中的查询也可以用聚集函数来实现，事实上，用聚集函数实现子查询通常比直接用any或all查询效率要高。</p>
<p><img src="\images\any与all和聚集函数对应关系表.jpg" alt="any与all和聚集函数对应关系表"></p>
</li>
<li><p>带有exists谓词的子查询</p>
<ul>
<li><p>exists代表存在量词∃。带有exists谓词的子查询不返回任何数据，只产生逻辑真值”true”或逻辑假值”false”。</p>
<p>例子：课本P109 例3.60</p>
</li>
<li><p>使用存在量词exists后，若内层查询结果非空，则外层的where子句返回真值，否则返回假值。</p>
</li>
<li><p>由exists引出的子查询，其目标列表达式通常都用*，因为带exists的子查询只返回真值或假值，给出列名无实际意义。</p>
</li>
<li><p>与exists谓词相对应的是not exists谓词。使用存在量词not exists后，若内层查询结果为空，则外层的where子句返回真值，否则返回假值。</p>
</li>
<li><p><strong>一些带exists 或 not exists谓词的子查询不能被其他形式的子查询等价替换，但所有带in谓词、比较运算符、any和all谓词的子查询都能用带exists谓词的子查询等价替换。</strong></p>
</li>
<li><p>SQL中没有全称量词，但是可以把带有全称量词的谓词转换为等价的带有存在量词的谓词</p>
<p>例子：课本P110 例3.62、3.63</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>集合查询</p>
<p>select 语句的查询结果是元组的集合，所以多个select语句的结果可进行集合操作。<strong>集合操作主要包括并操作union、交操作intersect和差操作except。</strong></p>
<p><em>使用union将多个查询结果合并起来时，系统会自动去掉重复元组。如果要保留重复元组则用union all操作符。</em></p>
</li>
<li><p>基于派生表的查询</p>
<p>子查询不仅可以出现在where子句中，还可以出现在from子句中，这时子查询生成的临时派生表成为主查询的查询对象。</p>
<p>select Sno,Cno</p>
<p>from SC,(select Sno,Avg(Grade) from SC group by Sno) as Avg_sc(avg_sno,avg_grade)</p>
<p>where SC.Sno = Avg_sc.avg_sno and SC.Grade &gt;= Avg_grade</p>
<p>这里from子句中的子查询将生成一个派生表Avg_sc。该表由avg_sno和avg_grade两个属性组成，记录了每个学生的学号及平均成绩。主查询将SC表与Avg_sc按学号相等进行连接，选出选修课成绩大于其平均成绩的课程号。</p>
<p><strong>通过from子句生成派生表时，as关键字可以省略，但必须为派生关系指定一个别名。</strong></p>
</li>
<li><p>select 语句的一般格式：</p>
<p>select [ALL|DISTINCT]&lt;目标列表达式&gt;[别名][,&lt;目标列表达式&gt;[别名]]…</p>
<p>from &lt;表名或视图名&gt;[别名][,&lt;表名或视图名&gt;[别名]]…|(<select 语句>)[as]&lt;别名&gt;</select></p>
<p>[where &lt;条件表达式&gt;]</p>
<p>[group by&lt;列名1&gt;[having1&lt;条件表达式&gt;]]</p>
<p>[order by&lt;列名2&gt;[asc|desc]]</p>
<ol>
<li><p>目标列表达式的可选格式</p>
<p><img src="\images\目标列表达式的可选格式.jpg" alt="目标列表达式的可选格式"></p>
</li>
<li><p>聚集函数的一般格式</p>
<p><img src="\images\聚集函数的一般格式.jpg" alt="聚集函数的一般格式"></p>
</li>
<li><p>where子句的条件表达式的可选格式</p>
<p><img src="\images\where子句的条件表达式的可选格式.jpg" alt="where子句的条件表达式的可选格式"></p>
</li>
</ol>
</li>
</ul>
<h3 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h3><p>数据更新操作有三种:向表中添加若干行数据、修改表中的数据和删除表中的若干行数据。</p>
<ul>
<li><p>插入数据</p>
<ol>
<li><p>插入元组</p>
<p>insert into &lt;表名&gt;[(&lt;属性列1&gt;[,&lt;属性列2&gt;]…)]values(&lt;常量1&gt;[,常量2]…)</p>
<p>在into子句中指出了表名Student，并指出了新增加的元组在哪些属性上要赋值，属性的顺序可以与create table中的顺序不一样。values子句对新元组的各属性赋值，字符串常数要用单引号(英文符合)括起来。</p>
<p>例：</p>
<p>insert into SC(Sno,Cno) values(‘201215128’,’1’)</p>
<p><strong>关系数据库管理系统将在新插入记录的Grade列上自动的赋空值。</strong></p>
<p>或 insert into SC values(‘201215128’,’1’,NULL)</p>
<p><strong>因为没有指出SC的属性名，在Grade列上要明确给出空值。</strong></p>
</li>
<li><p>插入子查询结果</p>
<p>插入子查询结果的insert 语句格式为</p>
<p>insert into &lt;表名&gt;[(&lt;属性列1&gt;[,&lt;属性列2&gt;…]） 子查询；</p>
</li>
</ol>
</li>
<li><p>修改数据</p>
<p>修改操作又称为更新操作，其语句的一般格式为</p>
<p>update &lt;表名&gt;</p>
<p>set &lt;列名&gt;=&lt;表达式&gt;[，&lt;列名&gt;=&lt;表达式&gt;]…</p>
<p>[where &lt;条件&gt;]</p>
<p>其功能是修改指定表中满足where子句条件的元组。其中set子句给出&lt;表达式&gt;的值用于取代相应的属性列值。如果省略where子句，则表示要修改表中的所有元组。</p>
<ol>
<li><p>修改某一个元组的值</p>
<p>例3.73 将学生201215121的年龄改为22岁</p>
<p>update Student set Sage=22 where Sno=’201215121’</p>
</li>
<li><p>修改多个元组的值</p>
<p>例 3.74 将所有学生的年龄增加1岁</p>
<p>update Student set Sage=Sage+1</p>
</li>
<li><p>带子查询的修改语句</p>
<p>子查询也可以嵌套在update语句中，用以构造修改的条件</p>
<p>例 3.75 将计算机科学系全体学生的成绩置零。</p>
<p>update SC set Grade=0</p>
<p>where Sno in(select Sno from Student where Sdept=’CS’)</p>
</li>
</ol>
</li>
<li><p>删除数据</p>
<p>删除语句的一般格式为</p>
<p>delete from &lt;表名&gt; [where &lt;条件&gt;]；</p>
<ol>
<li>删除某一个元组的值</li>
<li>删除多个元组的值</li>
<li>带子查询的删除语句</li>
</ol>
</li>
</ul>
<h3 id="空值的处理"><a href="#空值的处理" class="headerlink" title="空值的处理"></a>空值的处理</h3><p>所谓的空值就是”不知道”或”不存在”或”无意义”的值。 </p>
<p>未完待续。。。</p>
<p>—&gt;                    </p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/06/杭电oj-1004/" rel="next" title="杭电oj-1004">
                <i class="fa fa-chevron-left"></i> 杭电oj-1004
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/08/22/hexo常用命令/" rel="prev" title="hexo常用命令">
                hexo常用命令 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库"><span class="nav-number">1.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一章-绪论"><span class="nav-number">1.1.</span> <span class="nav-text">第一章 绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库系统概述"><span class="nav-number">1.1.1.</span> <span class="nav-text">数据库系统概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据模型"><span class="nav-number">1.1.2.</span> <span class="nav-text">数据模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库系统的结构"><span class="nav-number">1.1.3.</span> <span class="nav-text">数据库系统的结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二章-关系数据库"><span class="nav-number">1.2.</span> <span class="nav-text">第二章 关系数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关系数据结构及形式化定义"><span class="nav-number">1.2.1.</span> <span class="nav-text">关系数据结构及形式化定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系操作"><span class="nav-number">1.2.2.</span> <span class="nav-text">关系操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系的完整性"><span class="nav-number">1.2.3.</span> <span class="nav-text">关系的完整性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系代数"><span class="nav-number">1.2.4.</span> <span class="nav-text">关系代数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三章-关系数据库标准语言SQL"><span class="nav-number">1.3.</span> <span class="nav-text">第三章 关系数据库标准语言SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL-概述"><span class="nav-number">1.3.1.</span> <span class="nav-text">SQL 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据定义"><span class="nav-number">1.3.2.</span> <span class="nav-text">数据定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据查询"><span class="nav-number">1.3.3.</span> <span class="nav-text">数据查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据更新"><span class="nav-number">1.3.4.</span> <span class="nav-text">数据更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空值的处理"><span class="nav-number">1.3.5.</span> <span class="nav-text">空值的处理</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>
